{"meta":{"title":"little_sun's blog","subtitle":"A blog of little_sun.","description":"A super spicy chicken","author":"little_sun","url":"http://www.zcysky.com"},"pages":[{"title":"categories","date":"2019-02-06T01:06:28.000Z","updated":"2019-02-06T01:14:49.852Z","comments":false,"path":"categories/index.html","permalink":"http://www.zcysky.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2019-02-06T00:56:40.000Z","updated":"2019-02-06T01:05:03.056Z","comments":true,"path":"about/index.html","permalink":"http://www.zcysky.com/about/index.html","excerpt":"","text":"About me一个初二学生，OIer，菜的一匹"},{"title":"tags","date":"2019-02-06T00:53:29.000Z","updated":"2019-02-06T00:53:53.445Z","comments":true,"path":"tags/index.html","permalink":"http://www.zcysky.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"题解 CF1063B 【Labyrinth】","slug":"CF1063B","date":"2019-02-06T04:25:24.000Z","updated":"2019-02-07T01:54:18.324Z","comments":true,"path":"2019/02/06/CF1063B/","link":"","permalink":"http://www.zcysky.com/2019/02/06/CF1063B/","excerpt":"只要bfs一下，向四个方向搜索，剪下枝，就A了（好像还跑的蛮快？） 是一道锻炼代码能力的好题","text":"只要bfs一下，向四个方向搜索，剪下枝，就A了（好像还跑的蛮快？） 是一道锻炼代码能力的好题 Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define check(x, y) (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m)//判断是否越界const int MaxN = 2010;const int dx[] = &#123;0, 1, -1, 0&#125;, dy[] = &#123;-1, 0, 0, 1&#125;;//bfs方向数组struct p&#123; int x, y; int cntx, cnty;&#125;;int ans;int n, m, x, y, limx, limy;std::string s[MaxN];int vis[MaxN][MaxN];int disx[MaxN][MaxN], disy[MaxN][MaxN];void bfs(int x, int y)&#123; memset(disx, 0x3f, sizeof(disx)); memset(disy, 0x3f, sizeof(disy) ); std::queue&lt;p&gt; q; q.push((p)&#123;x, y, 0, 0&#125;); disx[x][y] = disy[x][y] = 0; while (!q.empty()) &#123; p tmp = q.front(); q.pop(); x = tmp.x, y = tmp.y; for (int i = 0; i &lt;= 3; i++) &#123; int nx = x + dx[i], ny = y + dy[i]; if (!check(nx, ny) || s[nx][ny] == '*')//当前位置是否合法 continue; int cntx = tmp.cntx + bool(dy[i] == -1), cnty = tmp.cnty + bool(dy[i] == 1);//计算向左/右走步数 if (cntx &lt; std::min(disx[nx][ny], limx + 1) || cnty &lt; std::min(disy[nx][ny], limy + 1))//判断，剪枝 &#123; disx[nx][ny] = cntx; disy[nx][ny] = cnty;//更新向左/右走步数 q.push((p)&#123;nx, ny, cntx, cnty&#125;); &#125; &#125; &#125;&#125;int main()&#123; scanf(\"%d%d\", &amp;n, &amp;m); scanf(\"%d%d\", &amp;x, &amp;y), --x, --y; scanf(\"%d%d\", &amp;limx, &amp;limy); for (int i = 0; i &lt; n; i++) std::cin &gt;&gt; s[i]; bfs(x, y); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (disx[i][j] &lt;= limx &amp;&amp; disy[i][j] &lt;= limy) ++ans;//统计答案 printf(\"%d\\n\", ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://www.zcysky.com/categories/题解/"}],"tags":[{"name":"search","slug":"search","permalink":"http://www.zcysky.com/tags/search/"},{"name":"bfs","slug":"bfs","permalink":"http://www.zcysky.com/tags/bfs/"}]},{"title":"题解 P5018 【对称二叉树】","slug":"luogu5018","date":"2019-02-06T04:16:45.000Z","updated":"2019-02-07T01:48:51.007Z","comments":true,"path":"2019/02/06/luogu5018/","link":"","permalink":"http://www.zcysky.com/2019/02/06/luogu5018/","excerpt":"这题考察的是选手对D(大)F(法)S(师)的掌握程度 考完试有人说这题是马拉车，吓死我了","text":"这题考察的是选手对D(大)F(法)S(师)的掌握程度 考完试有人说这题是马拉车，吓死我了 首先，你把数据读入之后，先用一个大法师把以每个节点为根的子树的大小和权值都预处理出来，方便待会剪枝 然后，你对以每个节点为根的子树，都判断一下以下条件（这时刚才处理的东西就有用了） ① 左子树和右子树的节点数是否相等 ② 左子树和右子树的权值是否相等 ③ 以当前节点为根的子树大小是不是超过答案 第三个很重要，不加（洛谷数据）最后一个点会TLE 有一个显而易见的剪枝：因为答案至少是1，所以大小为1的子树就不用check了，不然浪费常数 然后就是暴力判了 递归下去，建立两个队列，保存当前处理到的左子树上和右子树上的节点，判左子树当前节点的左儿子和右子树当前节点的右儿子权值是否相等，右子树当前节点的左儿子和左子树当前节点的右儿子权值是否相等（注意对应） 还有判下对应的节点有没有一个是空的一个没空的情况 如果不相等就返回 相等的话就扔进队列（注意对应顺序！） 注意：上述处理一定要左右子树一起做，不能先处理一边，再处理另一边，不然会WA 到最后如果都可以的话就return true 附考场代码 不得不说，为了能过，我加了一堆卡常 3e6的输入规模应该还是要快读的吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117# include &lt;bits/stdc++.h&gt;# define R register const int MaxN = 1000010;struct node//节点&#123; int val; int l, r;&#125;;node a[MaxN];int f[MaxN], val[MaxN], ind[MaxN];//f[i]表示以i为根的子树大小，val表示以i为根的子树权值和，ind没啥用inline void read(int &amp;x)//快读&#123; x = 0; bool op = 1; char ch = getchar(); while(ch &gt; '9' || ch &lt; '0') &#123; if(ch == '-') op = 0; ch = getchar(); &#125; while(ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch - '0'), ch = getchar(); if(!op) x = -x;&#125;void dfs(int root)&#123; if(root == -1) return; if(a[root].l == -1 &amp;&amp; a[root].r == -1) f[root] = 1, val[root] = a[root].val; else &#123; dfs(a[root].l); dfs(a[root].r); f[root] = f[a[root].l] + f[a[root].r] + 1; val[root] = val[a[root].l] + val[a[root].r] + a[root].val; &#125;&#125;inline int check(int x)&#123; std::queue&lt;int&gt; l, r; l.push(x), r.push(x); while(!l.empty() || !r.empty()) &#123; if(l.empty() || r.empty()) return false;//一边空了，一边没空 R int lx = l.front(), rx = r.front(); l.pop(), r.pop(); if(a[lx].val != a[rx].val) return false; R int lson[3], rson[3]; lson[1] = a[lx].l, lson[2] = a[lx].r;//左子树当前节点的左儿子,左子树当前节点的右儿子 rson[1] = a[rx].l, rson[2] = a[rx].r;//右子树当前节点的左儿子,右子树当前节点的右儿子 if((lson[1] == -1 &amp;&amp; rson[2] != -1) || (lson[1] != -1 &amp;&amp; rson[2] == -1)) return false;//一边空了，一边没空 if((lson[2] == -1 &amp;&amp; rson[1] != -1) || (lson[2] != -1 &amp;&amp; rson[1] == -1)) return false;//一边空了，一边没空 if(lson[1] != -1) l.push(lson[1]); if(lson[2] != -1) l.push(lson[2]); if(rson[2] != -1) r.push(rson[2]); if(rson[1] != -1) r.push(rson[1]); //推进队列 &#125; return true;&#125;int main()&#123;// freopen(\"tree.in\", \"r\", stdin);// freopen(\"tree.out\", \"w\", stdout); R int n; scanf(\"%d\", &amp;n); for(R unsigned i = 1; i &lt;= n; ++i) read(a[i].val); for(R unsigned i = 1; i &lt;= n; ++i) read(a[i].l), read(a[i].r), ++ind[a[i].l], ++ind[a[i].r];//处理入度 R unsigned root; for(R unsigned i = 1; i &lt;= n; ++i) &#123; if(!ind[i]) &#123; root = i; break; &#125; &#125;//找树根 dfs(root);//预处理 int ans = 1; for(R unsigned i = 1; i &lt;= n; ++i)//枚举子树 &#123; if(f[a[i].l] != f[a[i].r]) continue;//剪枝1 if(val[a[i].l] != val[a[i].r]) continue;//剪枝2 if(f[i] &lt; ans || f[i] == 1) continue;//剪枝3 if(check(i)) ans = f[i];//更新答案 &#125; printf(\"%d\", ans); fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://www.zcysky.com/categories/题解/"}],"tags":[{"name":"Tree","slug":"Tree","permalink":"http://www.zcysky.com/tags/Tree/"},{"name":"DFS","slug":"DFS","permalink":"http://www.zcysky.com/tags/DFS/"}]},{"title":"题解 CF550A 【Two Substrings】","slug":"CF550A","date":"2019-02-06T04:14:25.000Z","updated":"2019-02-07T01:48:34.969Z","comments":true,"path":"2019/02/06/CF550A/","link":"","permalink":"http://www.zcysky.com/2019/02/06/CF550A/","excerpt":"思路：暴力判每一个”BA”出现的位置，二分查找他前/后有没有满足条件的”AB”,时间复杂度$O(n\\log_{2}n)$","text":"思路：暴力判每一个”BA”出现的位置，二分查找他前/后有没有满足条件的”AB”,时间复杂度$O(n\\log_{2}n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# include &lt;bits/stdc++.h&gt;const int MaxN = 100010;std::vector&lt;int&gt; a, b;//存下标int upper(int x)//二分后面的位置&#123; int l = 0, r = a.size(); while(l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if(a[mid] &gt; x) r = mid; else l = mid + 1; &#125; return l;&#125;int lower(int x)//二分前面的位置&#123; int l = -1, r = a.size() - 1; while(l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if(a[mid] &lt; x) l = mid; else r = mid - 1; &#125; return l;&#125;int main()&#123; std::string s; std::cin &gt;&gt; s; int len = s.length(); for(int i = 0; i &lt; len - 1; i++) &#123; std::string tmp = s.substr(i, 2); if(tmp == \"AB\") a.push_back(i); else if(tmp == \"BA\") b.push_back(i); &#125;//查找\"AB\"和\"BA\"出现的位置 if(a.size() == 0 || b.size() == 0) return 0 * printf(\"NO\");//特判 for(int i = 0; i &lt; b.size(); i++) &#123; int x = lower(b[i] - 1);//防重 int y = upper(b[i] + 1); if(x != -1 || y != a.size()) return 0 * printf(\"YES\"); &#125; printf(\"NO\"); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://www.zcysky.com/categories/题解/"}],"tags":[{"name":"二分","slug":"二分","permalink":"http://www.zcysky.com/tags/二分/"}]},{"title":"题解 P2485 【[SDOI2011]计算器】","slug":"luogu2485","date":"2019-02-06T04:03:04.000Z","updated":"2019-02-07T01:52:41.820Z","comments":true,"path":"2019/02/06/luogu2485/","link":"","permalink":"http://www.zcysky.com/2019/02/06/luogu2485/","excerpt":"第一问快速幂不讲了 第二问要你求的是$x*y \\equiv z \\mod p$ 即 $xy - kp = z$ 即 $xy + p*(-k) = z$ 就转换为$exgcd$的标准形式了（这个相信大家都会吧） 第三问BSGS模板题 有兴趣可以看P4195 exBSGS模板","text":"第一问快速幂不讲了 第二问要你求的是$x*y \\equiv z \\mod p$ 即 $xy - kp = z$ 即 $xy + p*(-k) = z$ 就转换为$exgcd$的标准形式了（这个相信大家都会吧） 第三问BSGS模板题 有兴趣可以看P4195 exBSGS模板注意$b$有可能大于$p$，所以要膜一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;#define ll long long#define int llstd::unordered_map&lt;int, int&gt; h;int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a; &#125;inline int mul(int a, int b, int p)&#123; ll ret = 0; while(b) &#123; if (b &amp; 1) ret = (ret + a) % p; a = (a + a) % p; b &gt;&gt;= 1; &#125; return ret;&#125;void exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if (b == 0) &#123; x = 1, y = 0; return; &#125; exgcd(b, a % b, x, y); int t = x; x = y, y = t - (a / b) * y;&#125;int solve1(int a, int b, int p)&#123; ll ret = 1; while (b) &#123; if (b &amp; 1) ret = mul(ret, a, p); a = mul(a, a, p); b &gt;&gt;= 1; &#125; return ret;&#125;int solve2(int a, int b, int p)&#123; int x = 0, y = 0; int g = gcd(a, p); if (b % g) return -1; exgcd(a, p, x, y); x *= (b / g); x = (x % p + p) % p; return x;&#125;int solve3(int a, int b, int p)&#123; if (b == 1) return 0; int cnt = 0, d, k = 1; while ((d = gcd(a, p)) ^ 1) &#123; if (b % d) return -1; b /= d, p /= d, ++cnt; k = mul(k, a / d, p); if (k == b) return cnt; &#125; int t = sqrt(p) + 1, tmp = 1; h.clear(); for (int i = 0; i &lt; t; i++) &#123; h[mul(tmp, b, p)] = i; tmp = mul(tmp, a, p); &#125; k = mul(k, tmp, p); for (int i = 1; i &lt;= t; i++) &#123; if (h.find(k) != h.end()) return i * t - h[k] + cnt; k = mul(k, tmp, p); &#125; return -1;&#125;signed main()&#123; int T, op; scanf(\"%lld%lld\", &amp;T, &amp;op); while (T--) &#123; int a, b, p; scanf(\"%lld%lld%lld\", &amp;a, &amp;b, &amp;p); if (op == 1) printf(\"%lld\\n\", solve1(a, b, p)); if (op == 2) &#123; b %= p; int ans = solve2(a, b, p); if (ans == -1) printf(\"Orz, I cannot find x!\\n\"); else printf(\"%lld\\n\", ans); &#125; if (op == 3) &#123; b %= p;//注意这个！ int ans = solve3(a, b, p); if (ans == -1) printf(\"Orz, I cannot find x!\\n\"); else printf(\"%lld\\n\", ans); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://www.zcysky.com/categories/题解/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://www.zcysky.com/tags/数论/"}]},{"title":"题解 CF900D 【Unusual Sequences】","slug":"CF900D","date":"2019-02-06T03:44:54.000Z","updated":"2019-02-07T01:53:58.092Z","comments":true,"path":"2019/02/06/CF900D/","link":"","permalink":"http://www.zcysky.com/2019/02/06/CF900D/","excerpt":"可以发现如果$x$不整除$y$那么肯定无解 不然我们可以发现其实求的就是和为$y/x$且$gcd(a_1,a_2,\\cdots,a_n)=1$的序列个数 容易发现所有和为$y$的序列个数为$2^{n-1}$ 而所有$gcd$不为$1$的序列，把每个数除以$gcd$,就又回到原题了 所以枚举每个可能的$gcd$(约数)，递归计算即可。","text":"可以发现如果$x$不整除$y$那么肯定无解 不然我们可以发现其实求的就是和为$y/x$且$gcd(a_1,a_2,\\cdots,a_n)=1$的序列个数 容易发现所有和为$y$的序列个数为$2^{n-1}$ 而所有$gcd$不为$1$的序列，把每个数除以$gcd$,就又回到原题了 所以枚举每个可能的$gcd$(约数)，递归计算即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define ll long longconst ll mod = 1e9 + 7;std::map&lt;int, int&gt; m;std::vector&lt;int&gt; v, vec;int fast_pow(ll a, ll n)&#123; int ret = 1; while (n) &#123; if (n &amp; 1) ret = (1ll * ret * a) % mod; a = (1ll * a * a) % mod; n &gt;&gt;= 1; &#125; return ret;&#125;int solve(int x)&#123; if (m[x]) return m[x]; if (x == 1) &#123; m[x] = 1; return x; &#125; int sum = 0; int s = sqrt(x); for (int i = 1; i &lt;= s; i++) &#123; if (x % i == 0) &#123; if (i == 1 || i * i == x) sum = (sum + solve(i)) % mod; else sum = (sum + solve(i) % mod + solve(x / i) % mod) % mod; &#125; &#125; sum = (fast_pow(2, x - 1) - sum + mod) % mod; m[x] = sum; return sum;&#125;int main()&#123; ll x, y; std::cin &gt;&gt; x &gt;&gt; y; if (y % x != 0) return 0 * printf(\"0\"); y /= x; std::cout &lt;&lt; solve(y); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://www.zcysky.com/categories/题解/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://www.zcysky.com/tags/数论/"}]},{"title":"题解 P4867 【Gty的二逼妹子序列】","slug":"luogu4867","date":"2019-02-06T03:37:56.000Z","updated":"2019-02-07T01:48:59.440Z","comments":true,"path":"2019/02/06/luogu4867/","link":"","permalink":"http://www.zcysky.com/2019/02/06/luogu4867/","excerpt":"这种题一看直接莫队啊","text":"这种题一看直接莫队啊但是我们要想想怎么修改 一开始我想树状数组，但是我不会写o((⊙﹏⊙))o 后来看了一下题解，发现可以将值域分块，这样就可以做到查询$O(\\sqrt n)$，修改$O(1)$了 总复杂度$O(m \\sqrt n)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;#define getindex(x) ((x - 1) * block + 1)#define getpos(x) ((x - 1) / block + 1)const int MaxN = 1e5 + 10, MaxM = 1e6 + 10;struct query&#123; int id, pos; int l, r, a, b;&#125;;query q[MaxM];int n, m, size, block;int a[MaxN], ans[MaxM], cnt[MaxN], sum[MaxN];inline int cmp(query a, query b)&#123; if (a.pos != b.pos) return a.pos &lt; b.pos; return a.r &lt; b.r;&#125;inline int read()&#123; int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;&#125;inline void ins(int x)&#123; ++cnt[a[x]]; if (cnt[a[x]] == 1) ++sum[getpos(a[x])];&#125;inline void del(int x)&#123; --cnt[a[x]]; if (cnt[a[x]] == 0) --sum[getpos(a[x])];&#125;inline int ask(int a, int b, int l, int r)&#123; int ans = 0, Posl = getpos(l), Posr = getpos(r); for (int i = Posl + 1; i &lt; Posr; i++) ans += sum[i]; if (Posl == Posr) &#123; for (int i = l; i &lt;= r; i++) if (cnt[i]) ++ans; &#125; else &#123; int L = getindex(Posr), R = getindex(Posl + 1) - 1; for (int i = l; i &lt;= R; i++) if (cnt[i]) ++ans; for (int i = L; i &lt;= r; i++) if (cnt[i]) ++ans; &#125; return ans;&#125;inline void solve()&#123; int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) &#123; while (l &gt; q[i].l) l--, ins(l); while (r &lt; q[i].r) r++, ins(r); while (l &lt; q[i].l) del(l), l++; while (r &gt; q[i].r) del(r), r--; ans[q[i].id] = ask(q[i].l, q[i].r, q[i].a, q[i].b); &#125;&#125;int main()&#123; n = read(), m = read(); size = pow(n, 0.55), block = sqrt(n); for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= m; ++i) &#123; q[i].l = read(), q[i].r = read(); q[i].a = read(), q[i].b = read(); q[i].id = i, q[i].pos = (q[i].l - 1) / size + 1; &#125; std::sort(q + 1, q + m + 1, cmp); solve(); for (int i = 1; i &lt;= m; i++) printf(\"%d\\n\", ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://www.zcysky.com/categories/题解/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://www.zcysky.com/tags/莫队/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://www.zcysky.com/tags/Data-Structure/"},{"name":"分块","slug":"分块","permalink":"http://www.zcysky.com/tags/分块/"}]},{"title":"题解 P4396 【[AHOI2013]作业】","slug":"luogu4396","date":"2019-02-06T03:25:01.000Z","updated":"2019-02-07T01:49:08.921Z","comments":true,"path":"2019/02/06/luogu4396/","link":"","permalink":"http://www.zcysky.com/2019/02/06/luogu4396/","excerpt":"这题其实跟Gty的二逼妹子序列非常像 把那题代码改改就行了 思路：莫队+分块","text":"这题其实跟Gty的二逼妹子序列非常像 把那题代码改改就行了 思路：莫队+分块首先区间问题，可以离线，马上想到莫队 然后发现不会修改？怎么办？ (好像可以树状数组做，可是我不会o((⊙﹏⊙))o 我们可以把值域分块，这样就可以做到每次查询$O(\\sqrt n)$，修改$O(1)$了 总复杂度$O(m \\sqrt n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;#define getpos(x) ((x - 1) / block + 1)#define getblock(x) ((x - 1) * block + 1)const int MaxN = 100010;struct query&#123; int id, pos; int l, r, a, b;&#125;;query q[MaxN];int n, m, size, block;int a[MaxN], cnt[MaxN], sum[MaxN][3], ans[MaxN][3];inline int cmp(query a, query b)&#123; if (a.pos != b.pos) return a.pos &lt; b.pos; return a.r &lt; b.r;&#125;inline int read()&#123; int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;&#125;inline void add(int x)&#123; ++cnt[a[x]]; ++sum[getpos(a[x])][1]; if (cnt[a[x]] == 1) ++sum[getpos(a[x])][2];&#125;inline void del(int x)&#123; --cnt[a[x]]; --sum[getpos(a[x])][1]; if (cnt[a[x]] == 0) --sum[getpos(a[x])][2];&#125;inline void ask(int x)&#123; int id = q[x].id, l = q[x].a, r = q[x].b, Posl = getpos(q[x].a), Posr = getpos(q[x].b); for (int i = Posl + 1; i &lt; Posr; i++) ans[id][1] += sum[i][1], ans[id][2] += sum[i][2]; if (Posl == Posr) &#123; for (int i = l; i &lt;= r; i++) &#123; ans[id][1] += cnt[i]; if (cnt[i]) ans[id][2]++; &#125; &#125; else &#123; int L = getblock(Posr), R = getblock(Posl + 1) - 1; for (int i = l; i &lt;= R; i++) &#123; ans[id][1] += cnt[i]; if (cnt[i]) ans[id][2]++; &#125; for (int i = L; i &lt;= r; i++) &#123; ans[id][1] += cnt[i]; if (cnt[i]) ans[id][2]++; &#125; &#125;&#125;inline void solve()&#123; int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) &#123; while (l &gt; q[i].l) --l, add(l); while (r &lt; q[i].r) ++r, add(r); while (l &lt; q[i].l) del(l), l++; while (r &gt; q[i].r) del(r), r--; ask(i); &#125;&#125;int main()&#123; n = read(), m = read(); size = pow(n, 0.55), block = sqrt(n); for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= m; i++) &#123; q[i].l = read(), q[i].r = read(); q[i].a = read(), q[i].b = read(); q[i].id = i, q[i].pos = (q[i].l - 1) / size + 1; &#125; std::sort(q + 1, q + m + 1, cmp); solve(); for (int i = 1; i &lt;= m; i++) printf(\"%d %d\\n\", ans[i][1], ans[i][2]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://www.zcysky.com/categories/题解/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://www.zcysky.com/tags/莫队/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://www.zcysky.com/tags/Data-Structure/"},{"name":"分块","slug":"分块","permalink":"http://www.zcysky.com/tags/分块/"}]},{"title":"题解 CF375D 【Tree and Queries】","slug":"CF375D","date":"2019-02-06T03:16:31.000Z","updated":"2019-02-07T01:48:07.130Z","comments":true,"path":"2019/02/06/CF375D/","link":"","permalink":"http://www.zcysky.com/2019/02/06/CF375D/","excerpt":"首先，子树上的查询问题可以通过$DFS​$序转为序列问题","text":"首先，子树上的查询问题可以通过$DFS​$序转为序列问题 再一看，没有修改，可以离线，这不就是莫队吗？ 我们用$sum_i$表示出现次数$\\geq i$的个数 用$val_i$表示第$i$种颜色的出现次数 那么每次修改时只要$O(1)$修改$sum$和$val​$即可 详见代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;const int MaxN = 100010;struct node&#123; int val, dfn, r, id;&#125;;struct query&#123; int l, r; int pos, id, k;&#125;;struct edge&#123; int next, to;&#125;;node a[MaxN];query q[MaxN];edge e[MaxN &lt;&lt; 1];int n, m, cnt, dfscnt, size;int head[MaxN], ans[MaxN], sum[MaxN], val[MaxN];inline int comp(node a, node b) &#123; return a.dfn &lt; b.dfn; &#125;inline int cmp(query a, query b)&#123; if (a.pos != b.pos) return a.pos &lt; b.pos; return a.r &lt; b.r;&#125;inline void add_edge(int u, int v)&#123; ++cnt; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;&#125;inline void dfs(int u)&#123; a[u].dfn = ++dfscnt; for (int i = head[u]; i; i = e[i].next) &#123; int v = e[i].to; if (!a[v].dfn) dfs(v); &#125; a[u].r = dfscnt;&#125;inline int read()&#123; int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;&#125;inline void add(int x) &#123; ++val[a[x].val], ++sum[val[a[x].val]]; &#125;inline void del(int x) &#123; --sum[val[a[x].val]], --val[a[x].val]; &#125;inline void solve()&#123; int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) &#123; while (l &gt; q[i].l) --l, add(l); while (r &lt; q[i].r) ++r, add(r); while (l &lt; q[i].l) del(l), ++l; while (r &gt; q[i].r) del(r), --r; ans[q[i].id] = sum[q[i].k]; &#125;&#125;int main()&#123; n = read(), m = read(); size = pow(n, 0.55); for (int i = 1; i &lt;= n; i++) a[i].val = read(), a[i].id = i; for (int i = 1; i &lt;= n - 1; i++) &#123; int u = read(), v = read(); add_edge(u, v); add_edge(v, u); &#125; dfs(1); for (int i = 1; i &lt;= m; i++) &#123; int v, k; v = read(), k = read(); q[i].l = a[v].dfn, q[i].r = a[v].r, q[i].k = k; q[i].id = i, q[i].pos = (q[i].l - 1) / size + 1; &#125; std::sort(q, q + m + 1, cmp); std::sort(a + 1, a + n + 1, comp); solve(); for (int i = 1; i &lt;= m; i++) printf(\"%d\\n\", ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://www.zcysky.com/categories/题解/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://www.zcysky.com/tags/莫队/"},{"name":"DFS序","slug":"DFS序","permalink":"http://www.zcysky.com/tags/DFS序/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"http://www.zcysky.com/tags/Data-Structure/"}]},{"title":"Introduce to Dijkstra","slug":"dijkstra","date":"2019-02-06T00:03:18.000Z","updated":"2019-02-07T01:49:32.120Z","comments":true,"path":"2019/02/06/dijkstra/","link":"","permalink":"http://www.zcysky.com/2019/02/06/dijkstra/","excerpt":"前言 $SPFA​$算法由于它上限 $O(NM) = O(VE)​$的时间复杂度,被卡掉的几率很大.在算法竞赛中,我们需要一个更稳定的算法:$dijkstra​$.","text":"前言 $SPFA​$算法由于它上限 $O(NM) = O(VE)​$的时间复杂度,被卡掉的几率很大.在算法竞赛中,我们需要一个更稳定的算法:$dijkstra​$. 什么是$dijkstra$? $dijkstra​$是一种单源最短路径算法,时间复杂度上限为$O(n^2)​$(朴素),在实际应用中较为稳定$;​$加上堆优化之后更是具有$O((n+m)\\log_{2}n)​$的时间复杂度,在稠密图中有不俗的表现. $dijkstra$的原理/流程? $dijkstra$本质上的思想是贪心,它只适用于不含负权边的图. 我们把点分成两类,一类是已经确定最短路径的点,称为”白点”,另一类是未确定最短路径的点,称为”蓝点” $dijkstra$的流程如下$:$ $1.$ 初始化$dis[start] = 0,$其余节点的$dis$值为无穷大. $2.$ 找一个$dis$值最小的蓝点$x,$把节点$x$变成白点. $3.$ 遍历$x$的所有出边$(x,y,z),$若$dis[y] &gt; dis[x] + z,$则令$dis[y] = dis[x] + z$ $4.$ 重复$2,3$两步,直到所有点都成为白点$.$ 时间复杂度为$O(n^2)$ $dijkstra$为什么是正确的 当所有边长都是非负数的时候,全局最小值不可能再被其他节点更新.所以在第$2$步中找出的蓝点$x$必然满足$:dis[x]$已经是起点到$x$的最短路径$.$我们不断选择全局最小值进行标记和拓展,最终可以得到起点到每个节点的最短路径的长度 图解 (令$start = 1$) 开始时我们把$dis[start]$初始化为$0$,其余点初始化为$inf$ 第一轮循环找到$dis$值最小的点$1$,将$1$变成白点,对所有与$1$相连的蓝点的$dis$值进行修改,使得$dis[2]=2,dis[3]=4,dis[4]=7$ 第二轮循环找到$dis$值最小的点$2$,将$2$变成白点,对所有与$2$相连的蓝点的$dis$值进行修改,使得$dis[3]=3,dis[5]=4$ 第三轮循环找到$dis$值最小的点$3$,将$3$变成白点,对所有与$2$相连的蓝点的$dis$值进行修改,使得$dis[4]=4$ 接下来两轮循环分别将$4,5$设为白点,算法结束,求出所有点的最短路径 时间复杂度$O(n^2)$ 为什么$dijkstra$不能处理有负权边的情况? 我们来看下面这张图 $2$到$3$的边权为$-4$,显然从$1$到$3$的最短路径为$-2$ $(1-&gt;2-&gt;3).$但在循环开始时程序会找到当前$dis$值最小的点$3$,并标记它为白点. 这时的$dis[3]=1,$然而$1$并不是起点到$3$的最短路径.因为$3$已经被标为白点,所以$dis[3]$不会再被修改了.我们在边权存在负数的情况下得到了错误的答案. $dijkstra$的堆优化? 观察$dijkstra$的流程,发现步骤$2$可以优化 怎么优化呢? 我会zkw线段树!我会斐波那契堆! 我会堆! 我们可以用堆对$dis$数组进行维护,用$O(\\log_{2}n)$的时间取出堆顶元素并删除,用$O(\\log_{2}n)$遍历每条边,总复杂度$O((n+m)\\log_{2}n)$ 范例代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;const int MaxN = 100010, MaxM = 500010;struct edge&#123; int to, dis, next;&#125;;edge e[MaxM];int head[MaxN], dis[MaxN], cnt;bool vis[MaxN];int n, m, s;inline void add_edge( int u, int v, int d )&#123; cnt++; e[cnt].dis = d; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;&#125;struct node&#123; int dis; int pos; bool operator &lt;( const node &amp;x )const &#123; return x.dis &lt; dis; &#125;&#125;;std::priority_queue&lt;node&gt; q;inline void dijkstra()&#123; dis[s] = 0; q.push( ( node )&#123;0, s&#125; ); while( !q.empty() ) &#123; node tmp = q.top(); q.pop(); int x = tmp.pos, d = tmp.dis; if( vis[x] ) continue; vis[x] = 1; for( int i = head[x]; i; i = e[i].next ) &#123; int y = e[i].to; if( dis[y] &gt; dis[x] + e[i].dis ) &#123; dis[y] = dis[x] + e[i].dis; if( !vis[y] ) &#123; q.push( ( node )&#123;dis[y], y&#125; ); &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf( \"%d%d%d\", &amp;n, &amp;m, &amp;s ); for(int i = 1; i &lt;= n; ++i)dis[i] = 0x7fffffff; for( register int i = 0; i &lt; m; ++i ) &#123; register int u, v, d; scanf( \"%d%d%d\", &amp;u, &amp;v, &amp;d ); add_edge( u, v, d ); &#125; dijkstra(); for( int i = 1; i &lt;= n; i++ ) printf( \"%d \", dis[i] ); return 0;&#125; 例题 入门模板:P3371 进阶模板:P4779 其余例题请右转洛谷题库,搜索”最短路” 后记 本文部分内容摘自李煜东《算法竞赛进阶指南》和《信息学竞赛一本通》 友情提示:正权图请使用$dijkstra$算法,负权图请使用$SPFA$算法 感谢洛谷各位管理员提供的平台博客传送门个人博客","categories":[{"name":"算法","slug":"算法","permalink":"http://www.zcysky.com/categories/算法/"}],"tags":[{"name":"dijkstra","slug":"dijkstra","permalink":"http://www.zcysky.com/tags/dijkstra/"},{"name":"Graph","slug":"Graph","permalink":"http://www.zcysky.com/tags/Graph/"}]}]}