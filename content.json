{"pages":[{"title":"About","text":"About me一个初二学生，OIer，菜的一匹","link":"/about/index.html"},{"title":"friends","text":"本校同学little_sun: little_sun LCuter: LCuter’s Blog 外省大佬Siyuan: Siyuan’s Blog yzhang: yzhang’s Blog","link":"/friends/index.html"},{"title":"summary","text":"比赛不要妄想写正解，首先保证暴力分拿到，毕竟暴力打好就能进队。 注意题目中的数据范围，避免Runtime Error的情况发生 斜率优化里的$k$是带$i$的项，$x$是带$j$的项，$y$是带$f_j$的项 注意双向边和单向边不要加错","link":"/summary/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"Todo","text":"集训队作业每日刷题记录2020.3.9 $\\texttt{AGC034E Complete Compress}$ 提交记录 2020.3.10 $\\texttt{AGC022E Median Replace}$ 提交记录 2020.3.11咕掉了QAQ 2020.3.12 $\\texttt{AGC024F Simple Subsequence Problem}$ 提交记录 2020.3.13 $\\texttt{CF504E Misha and LCP on Tree}$ 提交记录 2020.3.14 $\\texttt{AGC035D Add and Remove}$ 提交记录 $\\texttt{CF605E Intergalaxy Trips}$ 提交记录 2020.3.15 $\\texttt{AGC021E Ball Eat Chameleons}$提交记录","link":"/plan/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"AGC022E Median Replace","text":"题目大意你有一个长度为$n$的串$\\texttt{S}$，其中有一些位置上的字符是?，其他的字符则是$0/1$之间的一种 每次可以进行一步操作：选择$3$个连续的字符，并把它们用它们的中位数替换 求有多少种把?替换成$0/1$的方案使得在进行$\\frac{n-1}{2}$次操作后剩下的字符为$1$？ 分析我们先考虑如果给定一个符合条件的串，要怎么判定这个串是否合法。 我们维护一个栈，这个栈从栈底到栈顶由一段连续的$1$和一段连续的$0$组成 对于新的一个字符$\\texttt{c}$，我们分$0/1$情况考虑 $c=0$，我们发现连续的$3$个$0$可以被抵消成为$1$个$0$，所以如果原来栈顶有$2$个连续的$0$，那么就把这$3$个$0$抵消掉$2$个变成$1$个$0$，否则直接把这个$0$插入栈顶 $c=1$，如果栈顶是$0$，则可以将这个$0$与$1$抵消（因为再找一个数，$3$个数取中位数的话，结果只与新找的数有关），否则把这个$1$插入栈。（如果栈中已经有了两个$1$，则怎么合并剩下的都是$1$，所以如果栈中已经有了两个$1$就可以忽略新的这个$1$了） 然后我们发现栈中$1$的个数只有$0\\sim2$这$3$种情况，$0$的个数也只有$0\\sim2$这$3$种情况，所以栈的种类数只有$3 \\times 3 = 9$种 现在我们考虑怎么$\\texttt{dp}$：我们可以把当前栈的状态当做$\\texttt{dp}$的状态，设$f[i][j][k]$表示当前处理第$i$位，栈中有$j$个$1$和$k$个$0$，则我们就可以按照上述的方式转移，对于?只要当做$0/1$分别转移一次就可以了。（具体转移可参见代码） 时间复杂度$\\mathcal{O(n)}$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define sum(a, b, mod) (((a) + (b)) % mod)const int mod = 1e9 + 7;const int MaxN = 3e5 + 10;char s[MaxN];ll n, f[MaxN][3][3];void add(ll &amp;a, ll b) {a += b, ((a &gt; mod) ? (a -= mod) : 0); }int main(){ f[0][0][0] = 1; scanf(\"%s\", s + 1), n = strlen(s + 1); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; 3; j++) { for(int k = 0; k &lt; 3; k++) { if(s[i + 1] != '0') { if(k) add(f[i + 1][j][k - 1], f[i][j][k]); else add(f[i + 1][std::min(j + 1, 2)][k], f[i][j][k]); } if(s[i + 1] != '1') { if(k == 2) add(f[i + 1][j][1], f[i][j][k]); else add(f[i + 1][j][k + 1], f[i][j][k]); } } } } ll ans = 0; for(int i = 0; i &lt; 3; i++) for(int j = 0; j &lt;= i; j++) add(ans, f[n][i][j]); printf(\"%lld\\n\", ans); return 0;}","link":"/2020/03/11/AGC022E/"},{"title":"「20190219」赛后总结","text":"总的来说这场比赛打完感触还是蛮深的. 深切体会到了背模板的意义 $T1$ $s$到$t$的路径上所有点显然一定会走到，以$s$为根时$t$子树中的点显然走不到，而其它点都有$\\frac{1}{2}$的概率会走到。 时间复杂度$O(n log_2{n} + m)​$ $T2$ n较小时，我们可以直接用线性筛/埃氏筛法求出每个数的最小质因数。 考虑进行容斥。对于每个质数$x$，我们需要求出$1$~$n/x$中不被比$x$小的质数整除的数的个数。一种简单的思路是，对于$x \\leq k$的情况，我们进行常见的枚举子集容斥；对于$x&gt;k$的情况，$n/x$较小，我们就在$n/k$的范围内进行线性筛/埃氏筛法。 注意到进行子集容斥时，枚举子集后贡献形如$(-1)^i·\\frac{n}{S}$，而$\\frac{n}{S}$只有$O(\\sqrt n )$种取值，可以对这个进行记忆化。 复杂度$\\frac{n^{\\frac{3}{4}}}{\\sqrt{log_2 n}}$ $T3$ 点分治统计树上的情况，然后单独考虑经过剩下那条边的答案。 在环上按顺序枚举一个端点，用树状数组维护另一个端点到这条边的距离。 时间复杂度$O(nlog_2n)$ 总的来说，T1T3的思路基本都有，但是因为代码能力有限，写的题太少，没写出来。。。","link":"/2019/02/19/20190219/"},{"title":"AGC034E Complete Compress","text":"题目大意有一棵有$n$个节点的树，每个节点上有$0/1$枚棋子，每次可以选择两个棋子并移动到它们的路径上的相邻节点（满足路径长度至少为$2$），求把所有棋子移到同一个节点的最小花费（无解输出$-1$）。 $n \\leq 2 \\times 10 ^ 3$ 分析枚举最后汇聚到的点$\\texttt{root}$，并以$\\texttt{root}$为根建树 我们可以发现，如果存在一个合法的方案，则必然是每次选择不存在祖先关系的两枚棋子，同时向着他们的$\\texttt{lca}$处跳一格，重复若干步，直到所有棋子都在$\\texttt{root}$ 由此我们联想到一个经典模型：有$\\texttt{sum}$个节点被分成了若干个集合，每次要找到不在同一集合的两个节点匹配并抵消。 设$\\texttt{max}$为最大的集合的大小，则当$sum - max \\geq max$时，刚好可以消去$\\lfloor \\frac{sum}{2} \\rfloor$对节点 否则剩下$2 \\times max - sum$个来自最大集合的节点，消去了$sum - max$对 现在我们回到原问题，考虑在$u$处做这个操作，设$f_u$表示在$u$的子树里最多消去了多少对。 我们把所有$u$的子树内的有棋子的节点$v$拆成$dis(v, \\; u)$个节点，则我们有如下转移（仍然设$\\texttt{sum}$为总结点个数，$\\texttt{max}$为最大的集合的大小） $sum - max \\geq max$ ，此时$f_u=\\lfloor \\frac{sum}{2} \\rfloor$ $sum - max &lt; max$，此时需要最大子树$v$内的节点来抵消，此时$f_u=sum-max+ \\min (f_v, \\lfloor \\frac{2 \\times max - sum}{2} \\rfloor )$ 以$\\texttt{root}$为根的情况合法当且仅当$f_{root} = \\frac{\\Sigma_u dis(u, root)}{2}$，同时这也是以$\\texttt{root}$为根的答案 对$\\texttt{root}=1 - n$重复这个$\\texttt{dp}$过程，时间复杂度$\\texttt{O(}n^2\\texttt{)}$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define sum(a, b, mod) (((a) + (b)) % mod)const int MaxN = 1e4 + 10;const int inf = 0x3f3f3f3f;struct edge{ int next, to;};char s[MaxN];edge e[MaxN];int n, ans, cnt;int a[MaxN], head[MaxN], dis[MaxN], size[MaxN], f[MaxN];void init(){ for (int i = 1; i &lt;= n; i++) dis[i] = size[i] = f[i] = 0;}void add_edge(int u, int v){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}void dfs(int u, int fa){ size[u] = a[u]; int maxp = 0; for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (v == fa) continue; dfs(v, u), size[u] += size[v], dis[v] += size[v]; dis[u] += dis[v], maxp = ((dis[maxp] &gt; dis[v]) ? maxp : v); } if(!maxp) return (void) (f[u] = 0); if(dis[u] &gt;= 2 * (dis[maxp])) f[u] = (dis[u] / 2); else f[u] = dis[u] - dis[maxp] + std::min(f[maxp], (2 * dis[maxp] - dis[u]) / 2);}int main(){ ans = inf; n = read(), scanf(\"%s\", s + 1); for (int i = 1; i &lt;= n; i++) a[i] = s[i] - '0'; for (int i = 1; i &lt; n; i++) { int u = read(), v = read(); add_edge(u, v), add_edge(v, u); } for (int i = 1; i &lt;= n; i++) { init(), dfs(i, 0); if(dis[i] &amp; 1) continue; if (f[i] * 2 &gt;= dis[i]) ans = std::min(ans, dis[i] / 2); } printf(\"%d\\n\", (ans == inf) ? -1 : ans); return 0;}","link":"/2020/03/09/AGC034E/"},{"title":"AGC035D Add and Remove","text":"题目大意有一个长度为$n$的序列${a_i}$，每次可以选择连续的$3$个数，把中间那个数加到左右两个数上后删除中间那个数。 求最后剩下的两个数的最小值。 $n \\leq 18$ 分析我们发现最后的结果肯定是每一个$a_i$乘上一个系数的和，我们考虑倒着$\\texttt{dp}$ 设$\\texttt{f[l][r][x][y]}$表示当前区间的左右端点分别是$l, \\; r$，$[l, r]$之间的部分已被删除，$a_l$的系数为$x$，$a_r$的系数为$y$ 那么我们模仿区间$\\texttt{dp}$的形式，枚举一个中间点$\\texttt{mid} \\in (l, r)$则$f[l][r][x][y] = \\min{f[l][mid][x][x+y]+f[mid][r][x+y][y]+a[mid] \\times (x+y)}$ 由于$n$不大，直接搜索即可。 代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define sum(a, b, mod) (((a) + (b)) % mod)ll n, a[50];ll f(ll l, ll r, ll x, ll y){ ll ans = 1e18; if(r - l &lt;= 1) return 0; for(int i = l + 1; i &lt;= r - 1; i++) ans = std::min((f(l, i, x, x + y) + f(i, r, x + y, y) + a[i] * (x + y)), ans); return ans;}int main(){ scanf(\"%lld\", &amp;n); for(int i = 1; i &lt;= n; i++) scanf(\"%lld\", &amp;a[i]); printf(\"%lld\\n\", f(1, n, 1, 1) + a[1] + a[n]); return 0;}","link":"/2020/03/15/AGC035D/"},{"title":"「算法笔记」Dijkstra","text":"前言 $SPFA​$算法由于它上限 $O(NM) = O(VE)​$的时间复杂度,被卡掉的几率很大.在算法竞赛中,我们需要一个更稳定的算法:$dijkstra​$. 什么是$dijkstra$? $dijkstra​$是一种单源最短路径算法,时间复杂度上限为$O(n^2)​$(朴素),在实际应用中较为稳定$;​$加上堆优化之后更是具有$O((n+m)\\log_{2}n)​$的时间复杂度,在稠密图中有不俗的表现. $dijkstra$的原理/流程? $dijkstra$本质上的思想是贪心,它只适用于不含负权边的图. 我们把点分成两类,一类是已经确定最短路径的点,称为”白点”,另一类是未确定最短路径的点,称为”蓝点” $dijkstra$的流程如下$:$ $1.$ 初始化$dis[start] = 0,$其余节点的$dis$值为无穷大. $2.$ 找一个$dis$值最小的蓝点$x,$把节点$x$变成白点. $3.$ 遍历$x$的所有出边$(x,y,z),$若$dis[y] &gt; dis[x] + z,$则令$dis[y] = dis[x] + z$ $4.$ 重复$2,3$两步,直到所有点都成为白点$.$ 时间复杂度为$O(n^2)$ $dijkstra$为什么是正确的 当所有边长都是非负数的时候,全局最小值不可能再被其他节点更新.所以在第$2$步中找出的蓝点$x$必然满足$:dis[x]$已经是起点到$x$的最短路径$.$我们不断选择全局最小值进行标记和拓展,最终可以得到起点到每个节点的最短路径的长度 图解 (令$start = 1$) 开始时我们把$dis[start]$初始化为$0$,其余点初始化为$inf$ 第一轮循环找到$dis$值最小的点$1$,将$1$变成白点,对所有与$1$相连的蓝点的$dis$值进行修改,使得$dis[2]=2,dis[3]=4,dis[4]=7$ 第二轮循环找到$dis$值最小的点$2$,将$2$变成白点,对所有与$2$相连的蓝点的$dis$值进行修改,使得$dis[3]=3,dis[5]=4$ 第三轮循环找到$dis$值最小的点$3$,将$3$变成白点,对所有与$2$相连的蓝点的$dis$值进行修改,使得$dis[4]=4$ 接下来两轮循环分别将$4,5$设为白点,算法结束,求出所有点的最短路径 时间复杂度$O(n^2)$ 为什么$dijkstra$不能处理有负权边的情况? 我们来看下面这张图 $2$到$3$的边权为$-4$,显然从$1$到$3$的最短路径为$-2$ $(1-&gt;2-&gt;3).$但在循环开始时程序会找到当前$dis$值最小的点$3$,并标记它为白点. 这时的$dis[3]=1,$然而$1$并不是起点到$3$的最短路径.因为$3$已经被标为白点,所以$dis[3]$不会再被修改了.我们在边权存在负数的情况下得到了错误的答案. $dijkstra$的堆优化? 观察$dijkstra$的流程,发现步骤$2$可以优化 怎么优化呢? 我会zkw线段树!我会斐波那契堆! 我会堆! 我们可以用堆对$dis$数组进行维护,用$O(\\log_{2}n)$的时间取出堆顶元素并删除,用$O(\\log_{2}n)$遍历每条边,总复杂度$O((n+m)\\log_{2}n)$ 范例代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;const int MaxN = 100010, MaxM = 500010;struct edge{ int to, dis, next;};edge e[MaxM];int head[MaxN], dis[MaxN], cnt;bool vis[MaxN];int n, m, s;inline void add_edge( int u, int v, int d ){ cnt++; e[cnt].dis = d; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;}struct node{ int dis; int pos; bool operator &lt;( const node &amp;x )const { return x.dis &lt; dis; }};std::priority_queue&lt;node&gt; q;inline void dijkstra(){ dis[s] = 0; q.push( ( node ){0, s} ); while( !q.empty() ) { node tmp = q.top(); q.pop(); int x = tmp.pos, d = tmp.dis; if( vis[x] ) continue; vis[x] = 1; for( int i = head[x]; i; i = e[i].next ) { int y = e[i].to; if( dis[y] &gt; dis[x] + e[i].dis ) { dis[y] = dis[x] + e[i].dis; if( !vis[y] ) { q.push( ( node ){dis[y], y} ); } } } }}int main(){ scanf( \"%d%d%d\", &amp;n, &amp;m, &amp;s ); for(int i = 1; i &lt;= n; ++i)dis[i] = 0x7fffffff; for( register int i = 0; i &lt; m; ++i ) { register int u, v, d; scanf( \"%d%d%d\", &amp;u, &amp;v, &amp;d ); add_edge( u, v, d ); } dijkstra(); for( int i = 1; i &lt;= n; i++ ) printf( \"%d \", dis[i] ); return 0;} 例题 入门模板:P3371 进阶模板:P4779 其余例题请右转洛谷 题库,搜索”最短路” 后记 本文部分内容摘自李煜东《算法竞赛进阶指南》和《信息学竞赛一本通》 友情提示:正权图请使用$dijkstra$算法,负权图请使用$SPFA$算法 感谢洛谷 各位管理员提供的平台","link":"/2019/02/06/Algorithm-Dijkstra/"},{"title":"CF1141E Superhero Battle","text":"题目大意有一个有着$h$点血量的boss,你的每一个回合有$n$种攻击 第$i$种攻击可以对boss造成$-d[i]$的伤害($h=h+d[i]$) 求最早在什么时候能击败boss(即boss血量$\\leq0$) 题解首先我们发现,回合数越少越好(废话) 怎么让回合数最小呢？ 我们发现,让boss剩下最多(但是在一个回合内能够击杀)的血量时回合数最少 然后就没有然后了。。。 把boss的血量压到一个回合能击杀的范围内然后枚举即可 具体见代码(注意开long long!) Code123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define cmin(a, b) ((a &lt; b) ? a : b)#define cmax(a, b) ((a &lt; b) ? b : a)const int MaxN = 2e5 + 10;typedef std::pair&lt;int, int&gt; pa;ll h, n;ll d[MaxN], sum[MaxN];int main(){ scanf(\"%lld%lld\", &amp;h, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%lld\", &amp;d[i]), sum[i] = sum[i - 1] + d[i]; for (int i = 1; i &lt;= n; i++) if (h + sum[i] &lt;= 0) return 0 * printf(\"%d\\n\", i); if (sum[n] &gt;= 0) return 0 * printf(\"-1\"); ll min = *std::min_element(sum + 1, sum + n + 1); ll cnt = (h + min - 1) / (-sum[n]) + 1; h += cnt * sum[n]; for (int i = 1; i &lt;= n; i++) if (h + sum[i] &lt;= 0) return 0 * printf(\"%lld\\n\", i + cnt * n); return 0;}","link":"/2019/03/21/CF1141E/"},{"title":"「算法笔记」 莫队","text":"前言莫队，可是传说中能够解决所有离线区间问题的神奇算法 引子我们先来看这样一道题： 有一个包含了$n$个数的序列$a_i$ 有$m$次询问，每次询问$[l,r]$区间中有多少个不同的数 $n,m \\leq 5*10^4$ 你会怎么做？暴力？ 暴力复杂度是$O(nm)$的，会$T$ 12345678910111213for(int i = 1; i &lt;= m; i++){ int ans = 0; memset(cnt, 0, sizeof(cnt)); for(int j = l[i]; j &lt;= r[i]; j++) { ++cnt[a[i]]; if(cnt[a[i]] == 1) ++ans; } printf(\"%d\\n\", ans);}// 暴力-未优化版 我们来观察一下暴力： 暴力每次询问$[l_i,r_i]$时上一次询问的$[l_{i-1},r_{i-1}]$所存储下来的信息就都被抛弃了 如果我们把上一次查询存储下来的信息再利用呢？ 123456789101112131415//前面询问没有排序int l = 1, r = 0, sum = 0;for (int i = 1; i &lt;= m; i++){ while (l &gt; q[i].l) l--, cnt[a[l]]++, sum += ((cnt[a[l]] == 1) ? 1 : 0); while (r &lt; q[i].r) r++, cnt[a[r]]++, sum += ((cnt[a[r]] == 1) ? 1 : 0); while (l &lt; q[i].l) cnt[a[l]]--, sum -= ((cnt[a[l]] == 0) ? 1 : 0), l++; while (r &gt; q[i].r) cnt[a[r]]--, sum -= ((cnt[a[r]] == 0) ? 1 : 0), r--; printf(\"%d\\n\", sum);}// 暴力-优化*1 很不幸，这样写还是会$T$.出题人可以构造数据使你相邻两次查询没有相交项，然后这就成了一个比暴力还劣的算法 但是我们已经离真正的莫队很近了 我们可以把询问分块，把询问依照左端点分成$O(\\sqrt n)$块,块内再按右端点排序。 这样子算法的总复杂度就是$O(n \\sqrt n)$的 但是，这个复杂度要怎么证明呢？ 莫队的复杂度分析块内转移 左端点 在同一个块里面，由于左端点都在一个长度为$O(\\sqrt n)$的区间里面所以在同一块里面移动一次，左端点最多变化$O(\\sqrt n)$总共有$m$个询问，那么同一个块里面的左端点变化最多是$O(m\\sqrt n)$的 右端点 由于每个块里面的询问都按右端点排序所以右端点在一个块里面最多变化$n$有 $\\sqrt n$个块，那么右端点移动最多就是$O(n\\sqrt n)$ 跨块转移容易发现这样的转移总共会发生$\\sqrt n$次 左端点 单次跨块转移的复杂度为$O(\\sqrt n)$,总复杂度为$O(\\sqrt n * \\sqrt n)=O(n)$ 右端点 由于跨块时，右端点是无序的，所以在最坏情况下右端点单次转移的复杂度为$O(n)$,总复杂度为$O(n * \\sqrt n)=O(n \\sqrt n)$ 综上所述，莫队算法的复杂度是$O(n\\sqrt n)$(由于$m$与$n$在同一个数量级，所以统一一下就成了$O(n\\sqrt n)$了，毕竟这是渐进时间复杂度) 范例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#define ll long longconst int MaxN = 500010;struct query{ int l, r, id, pos; bool operator&lt;(const query &amp;x) const { if (pos == x.pos) return r &lt; x.r; else return pos &lt; x.pos; }};query q[MaxN];int a[MaxN], n, m, k;int cnt[MaxN &lt;&lt; 1], ans[MaxN];inline int read(){ int x = 0; char ch = getchar(); while(ch &gt; '9' || ch &lt; '0') ch = getchar(); while(ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}int main(){ n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); m = read(); int size = (int)pow(n, 0.55); //莫队的块大小不一定要根号n,可以视题目而定 for (int i = 1; i &lt;= m; i++) { q[i].l = read(), q[i].r = read(); q[i].id = i, q[i].pos = (q[i].l - 1) / size + 1; } std::sort(q + 1, q + m + 1); int l = 1, r = 0, sum = 0; for (int i = 1; i &lt;= m; i++) { while (l &gt; q[i].l) l--, cnt[a[l]]++, sum += ((cnt[a[l]] == 1) ? 1 : 0); while (r &lt; q[i].r) r++, cnt[a[r]]++, sum += ((cnt[a[r]] == 1) ? 1 : 0); while (l &lt; q[i].l) cnt[a[l]]--, sum -= ((cnt[a[l]] == 0) ? 1 : 0), l++; while (r &gt; q[i].r) cnt[a[r]]--, sum -= ((cnt[a[r]] == 0) ? 1 : 0), r--; ans[q[i].id] = sum; } for (int i = 1; i &lt;= m; i++) printf(\"%d\\n\", ans[i]); return 0;} 习题 P2709 小B的询问 普通莫队模板题，建议初学者从这道题入手 P1972 [SDOI2009]HH的项链 普通莫队模板题，建议初学者从这道题入手 P3901 数列找不同 可以转化成莫队来做 P1494 [国家集训队]小Z的袜子 普通莫队模板题 P4137 Rmq Problem / mex 普通莫队模板题，修改有一些思维难度 CF375D Tree and Queries 树上问题转区间问题，可以用莫队解决 SP3267 DQUERY - D-query HH的项链数据弱化版 P4396 [AHOI2013]作业 莫队套分块 P4867 Gty的二逼妹子序列 莫队套分块，是上题第二小问的数据加强版 P3709 大爷的字符串题 区间众数模板题，不要求在线 带修莫队留坑待填 树上莫队留坑待填","link":"/2019/02/10/Algorithm-莫队/"},{"title":"CF1063B 【Labyrinth】","text":"一道锻炼代码能力的好题 只要bfs一下，向四个方向搜索，剪下枝，就A了（好像还跑的蛮快？） Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define check(x, y) (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m)//判断是否越界const int MaxN = 2010;const int dx[] = {0, 1, -1, 0}, dy[] = {-1, 0, 0, 1};//bfs方向数组struct p{ int x, y; int cntx, cnty;};int ans;int n, m, x, y, limx, limy;std::string s[MaxN];int vis[MaxN][MaxN];int disx[MaxN][MaxN], disy[MaxN][MaxN];void bfs(int x, int y){ memset(disx, 0x3f, sizeof(disx)); memset(disy, 0x3f, sizeof(disy) ); std::queue&lt;p&gt; q; q.push((p){x, y, 0, 0}); disx[x][y] = disy[x][y] = 0; while (!q.empty()) { p tmp = q.front(); q.pop(); x = tmp.x, y = tmp.y; for (int i = 0; i &lt;= 3; i++) { int nx = x + dx[i], ny = y + dy[i]; if (!check(nx, ny) || s[nx][ny] == '*')//当前位置是否合法 continue; int cntx = tmp.cntx + bool(dy[i] == -1), cnty = tmp.cnty + bool(dy[i] == 1);//计算向左/右走步数 if (cntx &lt; std::min(disx[nx][ny], limx + 1) || cnty &lt; std::min(disy[nx][ny], limy + 1))//判断，剪枝 { disx[nx][ny] = cntx; disy[nx][ny] = cnty;//更新向左/右走步数 q.push((p){nx, ny, cntx, cnty}); } } }}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); scanf(\"%d%d\", &amp;x, &amp;y), --x, --y; scanf(\"%d%d\", &amp;limx, &amp;limy); for (int i = 0; i &lt; n; i++) std::cin &gt;&gt; s[i]; bfs(x, y); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (disx[i][j] &lt;= limx &amp;&amp; disy[i][j] &lt;= limy) ++ans;//统计答案 printf(\"%d\\n\", ans); return 0;}","link":"/2019/02/06/CF1063B/"},{"title":"CF1285E Delete a Segment","text":"题目大意你有$n$个区间$[l_i, r_i]$， 你要恰好删掉一个区间，使得剩下的$n-1$个区间的并的总和最多 eg. [1,2], [3,5], [3,7]的并是[1,2], [3,7] 题目分析首先我们将给定的区间进行离散化 由于区间端点相邻的区间并不算相交，所以离散化时要进行特殊处理$(x=x*2-1)$ 然后本题就变成了这样一个问题: 1.对于所有$[l_i, r_i]$, 把对应区间的数值$a_i$全部加上1，并统计此时所有区间并的个数$num$ 2.对于每个$[l_i, r_i]$, 求出该区间内满足$a_i=1$的连续段个数，并统计最大值$ans$ 那么，$ans+num$即为答案 对于步骤$1$，可以用差分求出；对于步骤$2$， 可以用前缀和求出（注意特判开头和结尾相等的情况） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define sum(a, b, mod) (((a) + (b)) % mod)const int MaxN = 1e6 + 10;std::map&lt;int, int&gt; m1, m2;int n, cnt, l[MaxN], r[MaxN], a[MaxN], s[MaxN];inline void prework(){ m1.clear(), m2.clear(); for (int i = 1; i &lt;= n; i++) m1[l[i]] = m1[r[i]] = 1; cnt = 0; for (std::map&lt;int, int&gt;::iterator it = m1.begin(); it != m1.end(); it++) m2[it-&gt;first] = ++cnt; for (int i = 1; i &lt;= n; i++) l[i] = m2[l[i]] * 2 - 1, r[i] = m2[r[i]] * 2 - 1;}inline int read(){ int x = 0, f = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') { if (ch == '-') f = 0; ch = getchar(); } while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return f ? x : (-x);}int main(){ int T = read(); while (T--) { n = read(), cnt = 0; for (int i = 1; i &lt;= n; i++) l[i] = read(), r[i] = read(); prework(), cnt = cnt * 2 - 1; for (int i = 1; i &lt;= n; i++) a[l[i]]++, a[r[i] + 1]--; for (int i = 1; i &lt;= cnt; i++) a[i] += a[i - 1]; int num = 0, ans = -1000000; for (int i = 1; i &lt;= cnt; i++) { s[i] = s[i - 1]; num += (a[i] &amp;&amp; !a[i - 1]); if (a[i] &gt; 1 &amp;&amp; a[i - 1] &lt;= 1) ++s[i]; } for (int i = 1; i &lt;= n; i++) { int cur = s[r[i]] - s[l[i] - 1] + ((a[l[i]] &gt; 1) &amp;&amp; (a[l[i] - 1] &gt; 1)) - 1; ans = std::max(ans, cur); } printf(\"%d\\n\", num + ans); for (int i = 0; i &lt;= cnt * 2; i++) a[i] = s[i] = 0; } return 0;}","link":"/2020/01/13/CF1285E/"},{"title":"CF1285D Dr. Evil Underscores","text":"题目大意你有一个数组${a_n}$,求一个数$x$ ，满足$\\max{a_i \\oplus x}$最小，输出这个最小值 题目分析首先看到xor操作我们可以想到01trie, 接下来我们来分析如何用01trie计算答案 容易发现这样一个结论:如果一个节点的两个孩子都存在，那么这一位的异或值只能是$1$ 设当前节点为$\\texttt{now}$, 当前节点处在第$\\texttt{dep}$位， 我们可以考虑这样一个过程 1.递归计算当前节点的孩子$\\texttt{ch[now][0], ch[now][1]}$的答案$\\texttt{ans[0], ans[1]}$，并求得$ans= \\min {ans[0], ans[1] }$ 2.若当前节点的两个孩子都存在，返回$ans+2^{dep}$，否则返回$ans$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define sum(a, b, mod) (((a) + (b)) % mod)const int MaxN = 5e6 + 10;const int lim = (1 &lt;&lt; 29);int n, cnt = 1, a[MaxN], num[MaxN], ch[MaxN][2];inline void insert(int x){ int now = 1; for (int i = lim; i; i &gt;&gt;= 1) { if (ch[now][!!(x &amp; i)]) now = ch[now][!!(x &amp; i)]; else ++num[now], now = ch[now][!!(x &amp; i)] = ++cnt; }}int query(int x, int k){ if (!num[x]) return 0; int ans = 1e9; if (ch[x][0]) ans = std::min(ans, query(ch[x][0], k &gt;&gt; 1)); if (ch[x][1]) ans = std::min(ans, query(ch[x][1], k &gt;&gt; 1)); return ((num[x] == 1) ? ans : (ans + k));}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}int main(){ n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(), insert(a[i]); printf(\"%d\\n\", query(1, lim)); return 0;}","link":"/2020/01/13/CF1285D/"},{"title":"CF1182E Product Oriented Recurrence","text":"题目大意给你$n,f_1,f_2,f_3,c$,让你求$f_n=c^{2n-6} \\times f_{n-1} \\times f_{n-2} \\times f_{n-3}$ 解析首先我们可以发现: $f_n \\times c^n = c^{3n-6} \\times f_{n-1} \\times f_{n-2} \\times f_{n-3}= c^{n-1} \\times f_{n-1} \\times c^{n-2} \\times f_{n-2} \\times c^{n-3} \\times f_{n-3}$ 设 $g_n=f_n*c_n$，则有$g_n=g_{n-1} \\times g_{n-2} \\times g_{n-3}$ 把它展开，发现$$g_n=g_{n-1} \\times g_{n-2} \\times g_{n-3}=g_{n-2}^2 \\times g_{n-3}^2 \\times g_{n-4} = g_{n-3}^4 \\times g_{n-4}^3 \\times g_{n-5}^2 = \\cdots = g_3^{h_{2n-5}} \\times g_2^{h_{2n-6}} \\times g_1^{h_{2n-7}}$$ 于是我们的工作就变成了求$h_n$ 观察oeis一下这个式子我们可以发现： $$h_{2n}=h_{2n-1}+h_{2n-3},h_{2n+1}=h_{2n-1}+h_{2n-2},$$ 我们设$a_n=h_{2n+1},b_n=h_{2n}$，则可以得出如下矩阵 我们又注意到$mod=10^9+7$,于是我们可以把次数模上$\\phi(mod)=10^9+6$(欧拉定理) 于是我们就可以快乐的用矩快计算次数啦 注意最后的$f_n=\\frac{g_n}{c^n}$哦 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;#define R register#define ll unsigned long long#define sum(a, b, mod) ((a + b) % mod)const ll mod = 1e9 + 7, mode = 1e9 + 6;ll fast_mul(ll a, ll b, ll mod){ ll ans = 0; while (b) { if (b &amp; 1) ans = (ans + a) % mod; a = (a + a) % mod; b &gt;&gt;= 1; } return ans;}ll fast_pow(ll a, ll b){ ll ret = 1; while (b) { if (b &amp; 1) ret = fast_mul(ret, a, mod) % mod; a = fast_mul(a, a, mod) % mod; b &gt;&gt;= 1; } return ret;}struct matrix{ ll n, m, a[10][10]; matrix(ll x, ll y) { n = x, m = y; memset(a, 0, sizeof(a)); }};matrix mul(matrix a, matrix b){ ll n = a.n, m = a.m, k = b.m; matrix c(n, k); for (ll i = 1; i &lt;= n; i++) for (ll l = 1; l &lt;= k; l++) for (ll j = 1; j &lt;= m; j++) c.a[i][j] = (c.a[i][j] + fast_mul(a.a[i][l], b.a[l][j], mode)) % mode; return c;}matrix pow_(matrix a, ll b){ matrix ret = a; while (b) { if (b &amp; 1ll) ret = mul(ret, a); a = mul(a, a); b &gt;&gt;= 1ll; } return ret;}inline matrix init(){ matrix a(3, 3); a.a[1][1] = a.a[1][3] = a.a[2][1] = a.a[3][1] = a.a[3][2] = 1; return a;}inline matrix init_(){ matrix a(3, 1); a.a[1][1] = a.a[2][1] = a.a[3][1] = 1; return a;}int main(){ ll f[4], n, c; std::cin &gt;&gt; n &gt;&gt; f[1] &gt;&gt; f[2] &gt;&gt; f[3] &gt;&gt; c; matrix a = init(), b = init_(), x = pow_(a, n - 4), y = pow_(a, n - 4), z = pow_(a, n - 5); x = mul(x, b), y = mul(y, b), z = mul(z, b); ll A = x.a[1][1], B = y.a[3][1], C = z.a[1][1], X = fast_mul(f[3], fast_pow(c, 3), mod), Y = fast_mul(f[2], fast_pow(c, 2), mod), Z = fast_mul(f[1], c, mod); ll ans = fast_mul(fast_mul(fast_mul(fast_pow(X, A), fast_pow(Y, B), mod), fast_pow(Z, C), mod), fast_pow(fast_pow(c, n), mod - 2llu), mod); std::cout &lt;&lt; ans; return 0;}","link":"/2019/10/18/CF1182E/"},{"title":"CF1299C Water Balance","text":"简要题意你有一个序列${a}$,你的每次操作可以把一段区间里的数全部变成这个区间的平均数，求能得到的字典序最小的序列 分析我们发现字典序最小时显然${a_i}$单调不降 那么我们可以维护一个单调栈，栈里维护的值${l,r,avr}$，表示该段区间的左端点、右端点、平均值 每次插入${i,i,a_i}$,然后暴力循环取出栈顶的两个节点$x, y$（$y$在$x$后插入）,如果满足$y.avr&lt;x.avr$则合并$x,y$，直到不能合并为止（具体细节可以看代码） 最后把栈中记录的值输出即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt; #define R register#define ll long long#define sum(a, b, mod) (((a) + (b)) % mod) const int MaxN = 1e6 + 10; struct node{ int l, r; double sum, len;}; int n;double a[MaxN];std::vector&lt;node&gt; vec; int main(){ int tmp; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;tmp), a[i] = tmp; for (int i = 1; i &lt;= n; i++) { vec.push_back((node){i, i, a[i], 1}); while (vec.size() &gt;= 2 &amp;&amp; (vec[vec.size() - 2].sum / vec[vec.size() - 2].len) &gt;= (vec[vec.size() - 1].sum / vec[vec.size() - 1].len)) { node x = (node){vec[vec.size() - 2].l, vec[vec.size() - 1].r, vec[vec.size() - 2].sum + vec[vec.size() - 1].sum, vec[vec.size() - 1].r - vec[vec.size() - 2].l + 1.0}; vec.pop_back(), vec.pop_back(), vec.push_back(x); } } for (int i = 0; i &lt; vec.size(); i++) { for (int j = vec[i].l; j &lt;= vec[i].r; j++) a[j] = (vec[i].sum / vec[i].len); } for (int i = 1; i &lt;= n; i++) printf(\"%.10lf\\n\", a[i]); return 0;}","link":"/2020/02/11/CF1299C/"},{"title":"CF375D 【Tree and Queries】","text":"子树上的查询问题可以通过$DFS$序转换为序列问题 我们用$sum_i$表示出现次数$\\geq i$的个数 用$val_i$表示第$i$种颜色的出现次数 那么每次修改时只要$O(1)$修改$sum$和$val​$即可 详见代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;const int MaxN = 100010;struct node{ int val, dfn, r, id;};struct query{ int l, r; int pos, id, k;};struct edge{ int next, to;};node a[MaxN];query q[MaxN];edge e[MaxN &lt;&lt; 1];int n, m, cnt, dfscnt, size;int head[MaxN], ans[MaxN], sum[MaxN], val[MaxN];inline int comp(node a, node b) { return a.dfn &lt; b.dfn; }inline int cmp(query a, query b){ if (a.pos != b.pos) return a.pos &lt; b.pos; return a.r &lt; b.r;}inline void add_edge(int u, int v){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;}inline void dfs(int u){ a[u].dfn = ++dfscnt; for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (!a[v].dfn) dfs(v); } a[u].r = dfscnt;}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline void add(int x) { ++val[a[x].val], ++sum[val[a[x].val]]; }inline void del(int x) { --sum[val[a[x].val]], --val[a[x].val]; }inline void solve(){ int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) { while (l &gt; q[i].l) --l, add(l); while (r &lt; q[i].r) ++r, add(r); while (l &lt; q[i].l) del(l), ++l; while (r &gt; q[i].r) del(r), --r; ans[q[i].id] = sum[q[i].k]; }}int main(){ n = read(), m = read(); size = pow(n, 0.55); for (int i = 1; i &lt;= n; i++) a[i].val = read(), a[i].id = i; for (int i = 1; i &lt;= n - 1; i++) { int u = read(), v = read(); add_edge(u, v); add_edge(v, u); } dfs(1); for (int i = 1; i &lt;= m; i++) { int v, k; v = read(), k = read(); q[i].l = a[v].dfn, q[i].r = a[v].r, q[i].k = k; q[i].id = i, q[i].pos = (q[i].l - 1) / size + 1; } std::sort(q, q + m + 1, cmp); std::sort(a + 1, a + n + 1, comp); solve(); for (int i = 1; i &lt;= m; i++) printf(\"%d\\n\", ans[i]); return 0;}","link":"/2019/02/06/CF375D/"},{"title":"CF1316D Nash Matrix","text":"题目大意有一个$n \\times n$大小的棋盘，棋盘的每个格子上有一个字母（是U,L,R,D,X中之一），其中U表示向上走，D表示向下走，L表示向左走，R表示向右走，X表示走到这个格子就停止。 现在给你$n ^ 2$个坐标$(x_{i,j}, y_{i, j})$表示从$(i, j)$出发能走到的位置（如果无限循环则为$-1$），你需要构造出这个棋盘，或者输出INVALID，$n \\leq 10^3$ 分析容易发现一个性质：所有终点相同的点形成独立的联通块 证明很显然，如果$A$的终点是$(x_1, y_1)$，$B$的终点是$(x_2,y_2)$($(x_1,y_1) \\not= (x_2, y_2)$)，且$A$有边连到$B$的话，那么$A$的终点就不可能是$(x_1, y_1)$，而会是$(x_2,y_2)$与题设矛盾。 那么问题就好解决了 我们首先忽略掉死循环的情况，对于一个（非死循环）联通块，我们可以从这个联通块的终点（即$(i,j)=(x_{i,j},y_{i,j})$的点）向外开始$\\texttt{DFS}$，遍历所有与他相邻的点并记录答案。 而对于死循环的情况，显然如果单独的一个点死循环的话肯定是不可能的，这时候输出INVALID即可 否则我们枚举两个相邻的点作为起点，把这两个点连成双元环，然后分别从这两个点开始$\\texttt{DFS}$，遍历所有在不经过其中一个点的情况下能走到的所有点并记录答案（详情参见代码） 最后，如果有某一个点没有被遍历到的话则输出INVALID，否则就输出VALID并输出前文处理出的答案 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;bits/stdc++.h&gt; #define R register#define ll long long#define sum(a, b, mod) (((a) + (b)) % mod)#define check(x, y) ((x &gt; 0) &amp;&amp; (x &lt;= n) &amp;&amp; (y &gt; 0) &amp;&amp; (y &lt;= n)) const int MaxN = 1e3 + 10;const char op[] = {'U', 'L', 'D', 'R', 'X'};const int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1}; int n, vis[MaxN][MaxN];char ans[MaxN][MaxN];std::vector&lt;std::pair&lt;int, int&gt;&gt; v;std::pair&lt;int, int&gt; a[MaxN][MaxN]; int nxt(int x, int y, int ex, int ey){ for (int i = 0; i &lt;= 3; i++) if (x + dx[i] == ex &amp;&amp; y + dy[i] == ey) return i; return -1;} inline int read(){ int x = 0, f = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') { if (ch == '-') f = 0; ch = getchar(); } while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return f ? x : (-x);} void dfs(int x, int y, int Dx) // 正常联通块求解{ if (ans[x][y]) return; ans[x][y] = op[Dx]; for (int i = 0; i &lt;= 3; i++) { int ex = x + dx[i], ey = y + dy[i]; if (check(ex, ey) &amp;&amp; a[ex][ey] == a[x][y]) dfs(ex, ey, i); }} void get(int x, int y) // 求死循环联通块大小{ vis[x][y] = 1, v.push_back(std::make_pair(x, y)); for (int i = 0; i &lt;= 3; i++) { int ex = x + dx[i], ey = y + dy[i]; if (check(ex, ey) &amp;&amp; a[ex][ey].first == -1 &amp;&amp; a[ex][ey].second == -1 &amp;&amp; !vis[ex][ey]) get(ex, ey); }} void Dfs(int x, int y, int banx, int bany, int Dx) // 死循环联通块遍历{ if (ans[x][y]) return; ans[x][y] = op[Dx]; for (int i = 0; i &lt;= 3; i++) { int ex = x + dx[i], ey = y + dy[i]; if (check(ex, ey) &amp;&amp; (a[ex][ey].first == -1 &amp;&amp; a[ex][ey].second == -1) &amp;&amp; (ex != banx || ey != bany)) Dfs(ex, ey, banx, bany, i); }} int main(){ n = read(); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) a[i][j].first = read(), a[i][j].second = read(); } for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (a[i][j].first == i &amp;&amp; a[i][j].second == j) dfs(i, j, 4); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (a[i][j].first == -1 &amp;&amp; a[i][j].second == -1 &amp;&amp; !vis[i][j]) { v.clear(), get(i, j); if (v.size() == 1) return 0 * printf(\"INVALID\"); for (int k = 1; k &lt; v.size(); k++) { int x = nxt(v[k - 1].first, v[k - 1].second, v[k].first, v[k].second); if (~x) { Dfs(v[k].first, v[k].second, v[k - 1].first, v[k - 1].second, x); x = nxt(v[k].first, v[k].second, v[k - 1].first, v[k - 1].second); Dfs(v[k - 1].first, v[k - 1].second, v[k].first, v[k].second, x); break; } } } } } for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (!ans[i][j]) return 0 * printf(\"INVALID\"); puts(\"VALID\"); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) putchar(ans[i][j]); puts(\"\"); } return 0; }","link":"/2020/03/07/CF1316D/"},{"title":"CF86D Powerful array","text":"怎么2700的题这么简单啊QAQ 长得非常像P2709 小B的询问，做法也一样 莫队离线乱搞做完了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define int long longconst int MaxN = 1000010;struct query{ int l, r, id, pos;};query q[MaxN];int n, t, size;int ans[MaxN], sum;int a[MaxN], cnt[MaxN];inline int cmp(query a, query b){ if (a.pos != b.pos) return a.pos &lt; b.pos; return a.r &lt; b.r;}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline void add(int x){ sum += a[x] * (2 * cnt[a[x]] + 1); cnt[a[x]]++;}inline void del(int x){ sum -= a[x] * (2 * cnt[a[x]] - 1); cnt[a[x]]--;}inline void solve(){ int l = 1, r = 0; for (int i = 1; i &lt;= t; i++) { while (l &gt; q[i].l) --l, add(l); while (r &lt; q[i].r) ++r, add(r); while (l &lt; q[i].l) del(l), ++l; while (r &gt; q[i].r) del(r), --r; ans[q[i].id] = sum; }}signed main(){ n = read(), t = read(); size = pow(n, 0.55); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt;= t; i++) { q[i].l = read(), q[i].r = read(); q[i].id = i, q[i].pos = (q[i].l - 1) / size + 1; } std::sort(q + 1, q + t + 1, cmp); solve(); for (int i = 1; i &lt;= t; i++) printf(\"%lld\\n\", ans[i]); return 0;}","link":"/2019/02/28/CF86D/"},{"title":"CF550A 【Two Substrings】","text":"思路：暴力判每一个”BA”出现的位置，二分查找他前/后有没有满足条件的”AB”,时间复杂度$O(n\\log_{2}n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# include &lt;bits/stdc++.h&gt;const int MaxN = 100010;std::vector&lt;int&gt; a, b;//存下标int upper(int x)//二分后面的位置{ int l = 0, r = a.size(); while(l &lt; r) { int mid = (l + r) &gt;&gt; 1; if(a[mid] &gt; x) r = mid; else l = mid + 1; } return l;}int lower(int x)//二分前面的位置{ int l = -1, r = a.size() - 1; while(l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; if(a[mid] &lt; x) l = mid; else r = mid - 1; } return l;}int main(){ std::string s; std::cin &gt;&gt; s; int len = s.length(); for(int i = 0; i &lt; len - 1; i++) { std::string tmp = s.substr(i, 2); if(tmp == \"AB\") a.push_back(i); else if(tmp == \"BA\") b.push_back(i); }//查找\"AB\"和\"BA\"出现的位置 if(a.size() == 0 || b.size() == 0) return 0 * printf(\"NO\");//特判 for(int i = 0; i &lt; b.size(); i++) { int x = lower(b[i] - 1);//防重 int y = upper(b[i] + 1); if(x != -1 || y != a.size()) return 0 * printf(\"YES\"); } printf(\"NO\"); return 0;}","link":"/2019/02/06/CF550A/"},{"title":"CF900D 【Unusual Sequences】","text":"数论好题 可以发现如果$x$不整除$y$那么肯定无解 不然我们可以发现其实求的就是和为$y/x$且$gcd(a_1,a_2,\\cdots,a_n)=1$的序列个数 容易发现所有和为$y$的序列个数为$2^{n-1}$ 而所有$gcd$不为$1$的序列，把每个数除以$gcd$,就又回到原题了 所以枚举每个可能的$gcd$(约数)，递归计算即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define ll long longconst ll mod = 1e9 + 7;std::map&lt;int, int&gt; m;std::vector&lt;int&gt; v, vec;int fast_pow(ll a, ll n){ int ret = 1; while (n) { if (n &amp; 1) ret = (1ll * ret * a) % mod; a = (1ll * a * a) % mod; n &gt;&gt;= 1; } return ret;}int solve(int x){ if (m[x]) return m[x]; if (x == 1) { m[x] = 1; return x; } int sum = 0; int s = sqrt(x); for (int i = 1; i &lt;= s; i++) { if (x % i == 0) { if (i == 1 || i * i == x) sum = (sum + solve(i)) % mod; else sum = (sum + solve(i) % mod + solve(x / i) % mod) % mod; } } sum = (fast_pow(2, x - 1) - sum + mod) % mod; m[x] = sum; return sum;}int main(){ ll x, y; std::cin &gt;&gt; x &gt;&gt; y; if (y % x != 0) return 0 * printf(\"0\"); y /= x; std::cout &lt;&lt; solve(y); return 0;}","link":"/2019/02/06/CF900D/"},{"title":"CodeChef TANDEM","text":"题目大意我们定义一个字符串$s$为$\\texttt{tandem}$当且仅当这个字符串能被表示三个相同的字符串$A$首尾相连的结果 对于一个字符串$s$的所有子串$s_{l \\cdots r}$，如果它是一个$\\texttt{tandem}$，则它是一个有趣的$\\texttt{tandem}$当且仅当$s_l s_{r+1}$，否则这就是一个无聊的$\\texttt{tandem}$ 现在，你需要统计有趣的和无聊的$\\texttt{tandem}$的数量 分析$O(n^3)$方法不说了，大家都会 $O(n^2)$方法我们枚举$A$的长度$L \\in [1, \\frac{n}{3}]$， 并统计所有长度为$3L$的$\\texttt{tandem}$ 我们考虑所有下标能被$L$整除的位置，即$s_0, s_L, s_{2L}, \\cdots$，不难发现对于每一个长度为$3L$的$\\texttt{tandem}$都会恰好覆盖这些位置中的连续$3$个，我们设这连续三个位置为$(i, j, k)$ 不难发现这些子串的起始位置$a \\in [i - L + 1, i]$， 如果这个子串是一个$\\texttt{tandem}$， 则有$s_{[a, a+L-1]}=s_{[a+L, a+2L-1]}=s_{[a+2L, a+3L-1]}$ 由于$a \\in [i - L + 1, i]$，所以我们有$a \\leq i \\leq a + L - 1$, $a + L \\leq j \\leq a + 2L - 1$, $a + 2L \\leq k \\leq a + 3L - 1$，所以我们可以把上述条件转化为如下条件：$$s_{[a,i]}=s_{[a+L,j]}=s_{[a+2L,k]} \\$$ $$s_{[i,a+L-1]}=s_{[j,a+2L-1]}=s_{[k,a+2L-1]}$$","link":"/2020/02/26/CodeChef TANDEM/"},{"title":"Codeforces Round 550 (Div.3) 题解","text":"Codeforces Round #550 (Div.3) 题解 A. Diverse Strings &amp; B. Parity Alternated Deletions太水了，略 C. Two Shuffled SequencesDescription你有一个长为$n$的数列，你要把它分成两个数列，满足一个数列单调递增，另一个数列单调递减 求任意一种方案 Solution根据抽屉原理，如果有$\\geq3​$个相同的数字那么肯定不行 否则对于出现两次的数，把它分别放在两个数列里 出现一次的数随便放在哪个数列里都行 然后就做完了 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define cmax(a, b) ((a &lt; b) ? b : a)#define cmin(a, b) ((a &lt; b) ? a : b)#define sum(a, b, mod) ((a + b) % mod)#define openfile(x) freopen(#x \".in\", \"r\", stdin), freopen(#x \".out\", \"w\", stdout)const int MaxN = 500010;int n, in, de;int a[MaxN], vis[MaxN], cnt[MaxN], inc[MaxN], dec[MaxN];int cmp(int a, int b){ return a &gt; b;}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}int main(){ n = read(); for (int i = 1; i &lt;= n; ++i) { a[i] = read(), ++cnt[a[i]]; if (cnt[a[i]] &gt;= 3) return 0 * printf(\"NO\"); } for (int i = 1; i &lt;= n; i++) { if (cnt[a[i]] == 1) inc[++in] = a[i]; else if (cnt[a[i]] == 2 &amp;&amp; vis[a[i]] == 1) dec[++de] = a[i]; else inc[++in] = a[i], ++vis[a[i]]; } std::sort(inc + 1, inc + in + 1); std::sort(dec + 1, dec + de + 1, cmp); printf(\"YES\\n\"); printf(\"%d\\n\", in); for (int i = 1; i &lt;= in; i++) printf(\"%d \", inc[i]); puts(\"\"); printf(\"%d\\n\", de); for (int i = 1; i &lt;= de; i++) printf(\"%d \", dec[i]); puts(\"\"); return 0;} D. Equalize Them AllDescription给定一个数列$a_i$,你有两种操作 操作$1​$,把$a_i​$赋值为$a_i+|a_i−a_j|​$ 操作$2$,把$a_i$赋值为$a_i-|a_i−a_j|$ 操作均需满足$|i-j|=1$ 求最小次数及方案 Solution贪心一下，你就知道 首先肯定是把所有数字全部变成出现次数最大的那个数时最优 所以你记录一下出现次数最大的那个数每次出现的位置，然后模拟一下 Finished Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define cmax(a, b) ((a &lt; b) ? b : a)#define cmin(a, b) ((a &lt; b) ? a : b)#define sum(a, b, mod) ((a + b) % mod)#define openfile(x) freopen(#x \".in\", \"r\", stdin), freopen(#x \".out\", \"w\", stdout)const int MaxN = 2e5 + 10;int n;int a[MaxN], cnt[MaxN];std::vector&lt;int&gt; vec;int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]), ++cnt[a[i]]; int max = 0, num = 0; for (int i = 1; i &lt;= n; i++) { if (max &lt; cnt[a[i]]) max = cnt[a[i]], num = a[i]; } printf(\"%d\\n\", n - max); if (max == n) return 0; vec.push_back(0); for (int i = 1; i &lt;= n; i++) { if (a[i] == num) vec.push_back(i); } for (int i = 1; i &lt; vec.size(); i++) { for (int j = vec[i] - 1; j &gt; vec[i - 1]; j--) { if (a[j] &gt; num) printf(\"%d %d %d\\n\", 2, j, j + 1); else printf(\"%d %d %d\\n\", 1, j, j + 1); } } if (vec[vec.size() - 1] &lt; n) { for (int i = vec[vec.size() - 1] + 1; i &lt;= n; i++) { if (a[i] &gt; num) printf(\"%d %d %d\\n\", 2, i, i - 1); else printf(\"%d %d %d\\n\", 1, i, i - 1); } } return 0;} E. Median StringDescription有两个长度为$k$的字符串 你要求它们的”中间字符串”(即两个字符串的平均值) 数据保证有解 Solution首先把两个字符串化成两个数字数组$a_i$,$b_i$$a&lt;b$ 然后按类似高精度的方式将两个串相减,再$÷2$，得到另一个串$c_i$ 然后让$a_i$加上$c_i$,Finish (注意进位！ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define cmax(a, b) ((a &lt; b) ? b : a)#define cmin(a, b) ((a &lt; b) ? a : b)#define sum(a, b, mod) ((a + b) % mod)#define openfile(x) freopen(#x \".in\", \"r\", stdin), freopen(#x \".out\", \"w\", stdout)const int MaxN = 500010;std::string s, t;int k, nums[MaxN], numt[MaxN], ans[MaxN], add[MaxN];int main(){ scanf(\"%d\", &amp;k); std::cin &gt;&gt; s &gt;&gt; t; if (s == t) { std::cout &lt;&lt; s; return 0; } for (int i = 1; i &lt;= k; i++) nums[i] = s[i - 1] - 'a' + 1; for (int i = 1; i &lt;= k; i++) numt[i] = t[i - 1] - 'a' + 1; for (int i = k; i &gt;= 1; i--) { while (nums[i] &gt; numt[i]) numt[i] += 26, numt[i - 1]--; if ((numt[i] - nums[i]) % 2) add[i + 1] += 13; add[i] = (numt[i] - nums[i]) / 2; } for (int i = k; i &gt;= 1; i--) { ans[i] += nums[i] + add[i]; while (ans[i] &gt; 26) ans[i - 1]++, ans[i] -= 26; while (ans[i] == 0) ans[i - 1]++, ans[i] += 26; } for (int i = 1; i &lt;= k; i++) printf(\"%c\", ans[i] + 'a' - 1); return 0;} F. Graph Without Long Directed PathsDescription你有一个无向图,没有重边和自环 你的任务是把这个无向图转成有向图，满足这个有向图里找不到长度$\\geq2$的边 Solution将这个图黑白染色 可以发现如果一条边连接的两个点如果都是同一个颜色，那么就不行 否则就从白向黑连边(黑向白也行) Finished. Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define cmax(a, b) ((a &lt; b) ? b : a)#define cmin(a, b) ((a &lt; b) ? a : b)#define sum(a, b, mod) ((a + b) % mod)#define openfile(x) freopen(#x \".in\", \"r\", stdin), freopen(#x \".out\", \"w\", stdout)const int MaxN = 500010;struct edge{ int to, next;};edge e[MaxN];int n, m, cnt;int head[MaxN], col[MaxN], u[MaxN], v[MaxN];inline void add_edge(int u, int v){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline void dfs(int u, int c){ col[u] = c; for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (col[v]) continue; dfs(v, (c == 1) ? 2 : 1); }}int main(){ n = read(), m = read(); for (int i = 1; i &lt;= m; i++) { u[i] = read(), v[i] = read(); add_edge(u[i], v[i]); add_edge(v[i], u[i]); } for (int i = 1; i &lt;= n; i++) if (!col[i]) dfs(i, 1); for (int i = 1; i &lt;= m; i++) { if (col[u[i]] == col[v[i]]) return 0 * printf(\"NO\"); } printf(\"YES\\n\"); for (int i = 1; i &lt;= m; i++) { if (col[u[i]] == 1) printf(\"1\"); else printf(\"0\"); } return 0;} 后记这是zcy第一次在cf的比赛中切$6$题耶(＾－＾)V 一定要庆祝一下","link":"/2019/04/02/Codeforces-Round-550/"},{"title":"「LOJ 144」 DFS序1","text":"一道经典的DFS序入门题. 很显然对整个子树的修改可以通过DFS序转化为序列问题 于是只要把树转化为序列，再在序列上跑树状数组就好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;#define int long long#define lowbit(x) (x &amp; (-x))const int MaxN = 1e6 + 10;struct edge{ int next, to;};struct node{ int dfn, val, r;};node a[MaxN];edge e[MaxN &lt;&lt; 1];int n, m, r, dfsnum, cnt;int head[MaxN], vis[MaxN], c[MaxN];inline int read(){ int x = 0, f = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') { if (ch == '-') f = 0; ch = getchar(); } while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch - '0'), ch = getchar(); return f ? x : (-x);}inline void add_edge(int u, int v){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;}inline void dfs(int u){ vis[u] = true, a[u].dfn = ++dfsnum; for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (!vis[v]) dfs(v); } a[u].r = dfsnum;}inline void modify(int pos, int x){ while (pos &lt;= n) { c[pos] += x; pos += lowbit(pos); }}inline int query(int pos){ int ans = 0; while (pos) { ans += c[pos]; pos -= lowbit(pos); } return ans;}signed main(){ n = read(), m = read(), r = read(); for (int i = 1; i &lt;= n; i++) a[i].val = read(); for (int i = 1; i &lt; n; i++) { int u = read(), v = read(); add_edge(u, v); add_edge(v, u); } dfs(r); for (int i = 1; i &lt;= n; i++) modify(a[i].dfn, a[i].val); for (int i = 1; i &lt;= m; i++) { int op = read(); if (op == 1) { int pos = read(), x = read(); modify(a[pos].dfn, x); } else { int pos = read(); printf(\"%lld\\n\", query(a[pos].r) - query(a[pos].dfn - 1)); } } return 0;}","link":"/2019/02/11/LOJ-144/"},{"title":"「LOJ 145」DFS序 2","text":"经典的DFS序入门题 题目都告诉你是什么算法了 和「LOJ 144」DFS序 1一样，只不过这次把单点查询的树状数组改成区间修改的线段树罢了 敲下模板就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;bits/stdc++.h&gt;#define ll long longconst int MaxN = 1000010;struct edge{ int to, next;};struct vertex{ int dfn, next, val;};struct node{ int l, r; ll sum, tag;};struct SegmentTree{ ll x[MaxN]; node t[MaxN &lt;&lt; 2]; void pushup(int id) { t[id].sum = t[id &lt;&lt; 1].sum + t[id &lt;&lt; 1 | 1].sum; } inline void build(int id, int l, int r) { t[id].l = l, t[id].r = r; if (l == r) { t[id].sum = x[l]; return; } int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); pushup(id); } inline void pushdown(int id) { if (t[id].tag) { t[id &lt;&lt; 1].tag += t[id].tag; t[id &lt;&lt; 1 | 1].tag += t[id].tag; t[id &lt;&lt; 1].sum += t[id].tag * 1ll * (t[id &lt;&lt; 1].r - t[id &lt;&lt; 1].l + 1); t[id &lt;&lt; 1 | 1].sum += t[id].tag * 1ll * (t[id &lt;&lt; 1 | 1].r - t[id &lt;&lt; 1 | 1].l + 1); t[id].tag = 0; } } inline void modify(int id, int l, int r, int val) { if (l &gt; t[id].r || r &lt; t[id].l) return; if (l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) { t[id].sum += val * 1ll * (t[id].r - t[id].l + 1); t[id].tag += val; return; } if (t[id].l == t[id].r) return; pushdown(id); modify(id &lt;&lt; 1, l, r, val); modify(id &lt;&lt; 1 | 1, l, r, val); pushup(id); } inline ll query(int id, int l, int r) { if (l &gt; t[id].r || r &lt; t[id].l) return 0; if (l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) return t[id].sum; if (t[id].l == t[id].r) return 0; pushdown(id); return query(id &lt;&lt; 1, l, r) + query(id &lt;&lt; 1 | 1, l, r); }} T;edge e[MaxN];vertex a[MaxN];int head[MaxN], vis[MaxN];int n, m, r, cnt, dfscnt;inline void add_edge(int u, int v){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;}inline int read(){ int x = 0, f = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') { if (ch == '-') f = 0; ch = getchar(); } while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return f ? x : (-x);}inline void dfs(int u){ a[u].dfn = vis[u] = ++dfscnt; for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (vis[v]) continue; dfs(v); } a[u].next = dfscnt;}int main(){ n = read(), m = read(), r = read(); for (int i = 1; i &lt;= n; ++i) a[i].val = read(); for (int i = 1; i &lt; n; i++) { int u = read(), v = read(); add_edge(u, v); add_edge(v, u); } dfs(r); for(int i = 1; i &lt;= n; i++) T.x[a[i].dfn] = a[i].val; T.build(1, 1, n); for (int i = 1; i &lt;= m; i++) { int op = read(); if (op == 1) { int pos = read(), x = read(); T.modify(1, a[pos].dfn, a[pos].next, x); } else { int pos = read(); printf(\"%lld\\n\", T.query(1, a[pos].dfn, a[pos].next)); } } return 0;}","link":"/2019/02/19/LOJ-145/"},{"title":"CF504E Misha and LCP on Tree","text":"题目大意给你一棵有$n$个节点的树，每个节点上有一个字符$c$。 有$m$次询问，每次询问$a\\sim b$路径上的字符串和$c \\sim d$路径上的字符串的最长公共前缀$\\texttt{(LCP)}$ $n \\leq 3 \\times 10^5，m \\leq 10^6$ 分析发现普通的$\\texttt{LCP}$可以通过二分$+$哈希求出，我们考虑把这个做法拓展到树上。 维护$\\texttt{h[u]}$表示根到$u$路径上的字符串哈希值，$\\texttt{revh[u]}$表示$u$到根路径上的哈希值，则$u \\sim v$路径上的哈希值可以表现为$\\texttt{revh[u, lca]} \\times \\texttt{base}^{dv} + \\texttt{h(lca,v])}$，其中$\\texttt{dv}$表示$\\texttt{v}$到$\\texttt{lca}$的距离；而询问$u$和$v$到$\\texttt{lca}$的哈希值可以视为一个序列问题解决。 回到原问题，我们二分$\\texttt{LCP}$的长度$\\texttt{k}$，并找到$\\texttt{(a, b), (c, d)}$路径上第$\\texttt{k}$个节点（记为$v_1, v_2$），判断$\\texttt{(a,v1)}$与$\\texttt{(c,v2)}$链上的哈希值是否相等，并调整二分区间，最后的$l$就是答案 时间复杂度$\\mathcal{O}\\texttt{((n + m) log n)}$，详细实现参见代码 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define sum(a, b, mod) (((a) + (b)) % mod)const int MaxN = 1e6 + 10;const int mod = 998244853;struct edge{ int next, to;};struct mod_t{ static int norm(int x) { return x + (x &gt;&gt; 31 &amp; mod); } int x; mod_t() {} mod_t(int v) : x(v) {} mod_t(long long v) : x(v) {} mod_t(char v) : x(v) {} mod_t operator+(const mod_t &amp;rhs) const { return norm(x + rhs.x - mod); } mod_t operator-(const mod_t &amp;rhs) const { return norm(x - rhs.x); } mod_t operator*(const mod_t &amp;rhs) const { return (ll)x * rhs.x % mod; }};edge e[MaxN &lt;&lt; 1];std::vector&lt;int&gt; up[MaxN], down[MaxN];char s[MaxN];int n, m, cnt;mod_t h[MaxN], revh[MaxN], powm[MaxN], invp[MaxN], base, inv;int son[MaxN], fa[MaxN][24], f[MaxN][24], Dep[MaxN], pos[MaxN];int head[MaxN], dep[MaxN], maxd[MaxN], fir[MaxN], lg2[MaxN], top[MaxN];void add_edge(int u, int v){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;}int querykth(int u, int k){ if (!k) return u; u = fa[u][lg2[k]], k -= (1 &lt;&lt; lg2[k]); k -= dep[u] - dep[top[u]], u = top[u]; return ((k &gt;= 0) ? up[u][k] : down[u][-k]);}int querylca(int u, int v){ int l = fir[u], r = fir[v], k; if (l &gt; r) std::swap(l, r); k = lg2[r - l + 1]; return (Dep[f[l][k]] &lt;= Dep[f[r - (1 &lt;&lt; k) + 1][k]]) ? pos[f[l][k]] : pos[f[r - (1 &lt;&lt; k) + 1][k]];}mod_t fast_pow(mod_t a, int b){ mod_t ret = 1; while (b) { if (b &amp; 1) ret = ret * a; a = a * a, b &gt;&gt;= 1; } return ret;}void init(){ srand(time(NULL)); powm[0] = invp[0] = 1, base = (rand() % 2000) + 1001; inv = fast_pow(base, mod - 2); for (int i = 1; i &lt;= n; i++) { powm[i] = (powm[i - 1] * 1ll * base); invp[i] = (invp[i - 1] * 1ll * inv); }}void prework(){ lg2[0] = -1; for (int i = 1; i &lt;= cnt; i++) lg2[i] = lg2[i &gt;&gt; 1] + 1, f[i][0] = i; for (int j = 1; (1 &lt;&lt; j) &lt;= cnt; j++) { for (int i = 1; i &lt;= cnt - (1 &lt;&lt; j) + 1; i++) f[i][j] = (Dep[f[i][j - 1]] &lt;= Dep[f[i + (1 &lt;&lt; (j - 1))][j - 1]]) ? f[i][j - 1] : f[i + (1 &lt;&lt; (j - 1))][j - 1]; }}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch - 48), ch = getchar(); return x;}void dfs(int u, int fa){ Dep[++cnt] = maxd[u] = dep[u] = dep[fa] + 1, ::fa[u][0] = fa; pos[cnt] = u, h[u] = h[fa] * 1ll * base + s[u]; fir[u] = cnt, revh[u] = revh[fa] + powm[dep[fa]] * s[u]; for (int i = 1; i &lt;= 20; i++) ::fa[u][i] = ::fa[::fa[u][i - 1]][i - 1]; for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (v == fa) continue; dfs(v, u), pos[++cnt] = u, Dep[cnt] = dep[u]; if (maxd[v] &gt; maxd[u]) maxd[u] = maxd[v], son[u] = v; }}void dfs1(int u, int top){ ::top[u] = top; if (u == top) { int x = u; for (int i = 0; i &lt;= maxd[u] - dep[u]; i++) up[u].push_back(x), x = fa[x][0]; x = u; for (int i = 0; i &lt;= maxd[u] - dep[u]; i++) down[u].push_back(x), x = son[x]; } if (son[u]) dfs1(son[u], top); for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (v != son[u] &amp;&amp; v != fa[u][0]) dfs1(v, v); }}int qhash(int u, int v, int lca, int flca){ int dv = dep[v] - dep[lca]; mod_t h1 = (revh[u] - revh[flca] + mod) * invp[dep[flca]], h2, H; h2 = (h[v] - h[lca] * powm[dv]), H = h1 * powm[dv] + h2; return H.x;}int get(int u, int v, int k){ int lca = querylca(u, v), d = dep[u] + dep[v] - 2 * dep[lca] + 1; return (k &lt;= dep[u] - dep[lca]) ? 1 : 0;}int path(int u, int v, int k){ int lca = querylca(u, v), d = dep[u] + dep[v] - 2 * dep[lca] + 1; if (k &lt;= dep[u] - dep[lca]) return querykth(u, k - 1); else return querykth(v, d - k);}int query(int a, int b, int c, int d){ if (s[a] != s[c]) return 0; int lca1 = querylca(a, b), flca1 = fa[lca1][0], d1 = dep[a] + dep[b] - 2 * dep[lca1] + 1; int lca2 = querylca(c, d), flca2 = fa[lca2][0], d2 = dep[c] + dep[d] - 2 * dep[lca2] + 1; int l = 1, r = std::min(d1, d2); // printf(\"debug: a = %d, b = %d, c = %d, d = %d, lca(a, b) = %d, lca(c, d) = %d\\n\", a, b, c, d, lca1, lca2); while (l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; int x1 = get(a, b, mid), x2 = get(c, d, mid); int v1 = path(a, b, mid), v2 = path(c, d, mid); // printf(\"Debug: l = %d, r = %d, mid = %d, v1 = %d, v2 = %d\\n\", l, r, mid, v1, v2); if (qhash(a, v1, (x1 ? v1 : lca1), (x1 ? fa[v1][0] : flca1)) == qhash(c, v2, (x2 ? v2 : lca2), (x2 ? fa[v2][0] : flca2))) l = mid; else r = mid - 1; } return l;}int main(){ scanf(\"%d\\n%s\", &amp;n, s + 1), init(); for (int i = 1; i &lt; n; i++) { int u = read(), v = read(); add_edge(u, v), add_edge(v, u); } m = read(), cnt = 0, dfs(1, 0), dfs1(1, 1), prework(); for (int i = 1; i &lt;= m; i++) { int a = read(), b = read(), c = read(), d = read(); printf(\"%d\\n\", query(a, b, c, d)); } return 0;}","link":"/2020/03/15/CF504E/"},{"title":"LOJ 6000「网络流 24 题」搭配飞行员","text":"很简单的网络流 对于每个正飞行员，从源点向它连一条容量为$1$的边 对于每个副飞行员，从它向汇点连一条容量为$1$的边 对于每一对可以配对的正/副飞行员，从正飞行员向副飞行员连一条容量为$1$的边 然后跑网络流模板即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define cmax(a, b) ((a &lt; b) ? b : a)#define cmin(a, b) ((a &lt; b) ? a : b)#define sum(a, b, mod) ((a + b) % mod)const int MaxN = 2e4 + 10;const int MaxM = 5e5 + 10;const int inf = (1 &lt;&lt; 30);struct edge{ int to, next, cap;};edge e[MaxM];int n, m, s = 20000, t = 20001, cnt = 1, ans;int head[MaxN], dep[MaxN], cur[MaxN], a[MaxN];inline void add(int u, int v, int c){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; e[cnt].cap = c; head[u] = cnt;}inline void add_edge(int u, int v, int c) { add(u, v, c), add(v, u, 0); }inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline int bfs(){ memset(dep, 0, sizeof(dep)); memcpy(cur, head, sizeof(head)); std::queue&lt;int&gt; q; dep[s] = 1; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i; i = e[i].next) { int v = e[i].to, c = e[i].cap; if (dep[v] || !c) continue; dep[v] = dep[u] + 1; q.push(v); } } return dep[t];}inline int dinic(int u, int flow){ if (u == t) return flow; int rest = flow; for (int i = cur[u]; i &amp;&amp; (flow - rest &lt; flow); i = e[i].next) { int v = e[i].to, c = e[i].cap; if (dep[v] != dep[u] + 1 || !c) continue; int k = dinic(v, cmin(rest, c)); if (!k) dep[v] = dep[u] + 1; else { e[i].cap -= k; e[i ^ 1].cap += k; rest -= k; } } if (flow - rest &lt; flow) dep[u] = -1; return flow - rest;}int main(){ n = read(), m = read(); int u, v; for (int i = 1; i &lt;= m; i++) add_edge(s, i, 1); for (int i = m + 1; i &lt;= n; i++) add_edge(i, t, 1); while (scanf(\"%d%d\", &amp;u, &amp;v) == 2) add_edge(u, v, 1); int now = 0; while (bfs()) while ((now = dinic(s, inf))) ans += now; printf(\"%d\\n\", ans); return 0;}","link":"/2019/05/09/LOJ-6000/"},{"title":"LOJ 6003「网络流 24 题」魔术球","text":"枚举答案，对于$(i,j)(i&lt;j)$,若$i&lt;j$且$i+j$是完全平方数，则从$i$向$j$连一条边 然后跑最小路径覆盖(可以参照LOJ 6002) 方案输出也类似上一题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define cmax(a, b) ((a &lt; b) ? b : a)#define cmin(a, b) ((a &lt; b) ? a : b)#define sum(a, b, mod) ((a + b) % mod)const int MaxN = 2e4 + 10;const int MaxM = 5e5 + 10;const int inf = (1 &lt;&lt; 30);struct edge{ int to, next, cap;};edge e[MaxM];int n, m, s = 20000, t = 20001, cnt = 1, ans, tmp;int head[MaxN], dep[MaxN], cur[MaxN], a[MaxN], vis[MaxN], to[MaxN];inline void add(int u, int v, int c){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; e[cnt].cap = c; head[u] = cnt;}inline void add_edge(int u, int v, int c) { add(u, v, c), add(v, u, 0); }inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline int bfs(){ memset(dep, 0, sizeof(dep)); memcpy(cur, head, sizeof(head)); std::queue&lt;int&gt; q; dep[s] = 1; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i; i = e[i].next) { int v = e[i].to, c = e[i].cap; if (dep[v] || !c) continue; dep[v] = dep[u] + 1; q.push(v); } } return dep[t];}inline int dinic(int u, int flow){ if (u == t) return flow; int rest = flow; for (int i = cur[u]; i &amp;&amp; (flow - rest &lt; flow); i = e[i].next) { int v = e[i].to, c = e[i].cap; if (dep[v] != dep[u] + 1 || !c) continue; int k = dinic(v, cmin(rest, c)); if (!k) dep[v] = dep[u] + 1; else { e[i].cap -= k; e[i ^ 1].cap += k; rest -= k; if (e[i].to &gt; 5000) vis[e[i].to - 5000] = 1; to[u] = e[i].to; } } if (flow - rest &lt; flow) dep[u] = -1; return flow - rest;}inline void solve(){ int now = 0; while (bfs()) while ((now = dinic(s, inf))) ans -= now;}int main(){ n = read(); while (1) { ans++, tmp++; for (int i = 1; i &lt; tmp; i++) { int x = sqrt(i + tmp); if (x * x == (i + tmp)) add_edge(i, tmp + 5000, 1); } add_edge(s, tmp, 1), add_edge(tmp + 5000, t, 1); solve(); if (ans &gt; n) break; } --tmp; printf(\"%d\\n\", tmp); for (int i = 1; i &lt;= tmp; i++) { if (vis[i]) continue; printf(\"%d \", i); int t = i; while (to[t]) { printf(\"%d \", to[t] - 5000); t = to[t] - 5000; } puts(\"\"); } return 0;}","link":"/2019/05/12/LOJ-6003/"},{"title":"LOJ 6002「网络流 24 题」最小路径覆盖","text":"1.建立两个集合$x$和$y$ 2.如果有一条边$&lt;u,v&gt;$,则从$x$集合中的$u$点连向$y$集合的$v$点，容量为$inf$ 3.从$s$向$x$中每一个点连边，从$y$中每一个点向$t$连边，容量为$1$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define cmax(a, b) ((a &lt; b) ? b : a)#define cmin(a, b) ((a &lt; b) ? a : b)#define sum(a, b, mod) ((a + b) % mod)const int MaxN = 2e4 + 10;const int MaxM = 5e5 + 10;const int inf = (1 &lt;&lt; 30);struct edge{ int to, next, cap;};edge e[MaxM];int n, m, s = 20000, t = 20001, cnt = 1, ans;int head[MaxN], dep[MaxN], cur[MaxN], a[MaxN], vis[MaxN], to[MaxN];inline void add(int u, int v, int c){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; e[cnt].cap = c; head[u] = cnt;}inline void add_edge(int u, int v, int c) { add(u, v, c), add(v, u, 0); }inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline int bfs(){ memset(dep, 0, sizeof(dep)); memcpy(cur, head, sizeof(head)); std::queue&lt;int&gt; q; dep[s] = 1; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i; i = e[i].next) { int v = e[i].to, c = e[i].cap; if (dep[v] || !c) continue; dep[v] = dep[u] + 1; q.push(v); } } return dep[t];}inline int dinic(int u, int flow){ if (u == t) return flow; int rest = flow; for (int i = cur[u]; i &amp;&amp; (flow - rest &lt; flow); i = e[i].next) { int v = e[i].to, c = e[i].cap; if (dep[v] != dep[u] + 1 || !c) continue; int k = dinic(v, cmin(rest, c)); if (!k) dep[v] = dep[u] + 1; else { e[i].cap -= k; e[i ^ 1].cap += k; rest -= k; if (e[i].to &gt; n) vis[e[i].to - n] = 1; to[u] = e[i].to; } } if (flow - rest &lt; flow) dep[u] = -1; return flow - rest;}inline void solve(){ int now = 0; while (bfs()) while ((now = dinic(s, inf))) ans += now;}int main(){ n = read(), m = read(); for (int i = 1; i &lt;= m; i++) { int u = read(), v = read(); add_edge(u, v + n, inf); } for (int i = 1; i &lt;= n; i++) add_edge(s, i, 1), add_edge(i + n, t, 1); solve(); for (int i = 1; i &lt;= n; i++) { if (vis[i]) continue; printf(\"%d \", i); int t = i; while (to[t]) { printf(\"%d \", to[t] - n); t = to[t] - n; } puts(\"\"); } printf(\"%d\\n\", n - ans); return 0;}","link":"/2019/05/12/LOJ-6002/"},{"title":"LOJ 6004「网络流 24 题」圆桌聚餐","text":"建模： 1.从源点向每个单位$x_i$连边，容量是该单位的人数 2.从每张餐桌$y_i$向汇点连边，容量是该餐桌能容纳的人数 3.从每个单位$x_i$向每张餐桌$y_j$连边，容量为$1$ 如果最大流量等于所有单位人数之和，则有解，否则无解。 方案： 对于每个单位$x_i$，该单位向$y$集合连出的所有满流量边即为该单位人员的安排情况（证明显然 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define cmax(a, b) ((a &lt; b) ? b : a)#define cmin(a, b) ((a &lt; b) ? a : b)#define sum(a, b, mod) ((a + b) % mod)const int MaxN = 2e4 + 10;const int MaxM = 5e5 + 10;const int inf = (1 &lt;&lt; 30);struct edge{ int to, next, cap;};edge e[MaxM];int n, m, s = 20000, t = 20001, cnt = 1, ans;int head[MaxN], dep[MaxN], cur[MaxN], a[MaxN];inline void add(int u, int v, int c){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; e[cnt].cap = c; head[u] = cnt;}inline void add_edge(int u, int v, int c) { add(u, v, c), add(v, u, 0); }inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline int bfs(){ memset(dep, 0, sizeof(dep)); memcpy(cur, head, sizeof(head)); std::queue&lt;int&gt; q; dep[s] = 1; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i; i = e[i].next) { int v = e[i].to, c = e[i].cap; if (dep[v] || !c) continue; dep[v] = dep[u] + 1; q.push(v); } } return dep[t];}inline int dinic(int u, int flow){ if (u == t) return flow; int rest = flow; for (int i = cur[u]; i &amp;&amp; (flow - rest &lt; flow); i = e[i].next) { int v = e[i].to, c = e[i].cap; if (dep[v] != dep[u] + 1 || !c) continue; int k = dinic(v, cmin(rest, c)); if (!k) dep[v] = dep[u] + 1; else { e[i].cap -= k; e[i ^ 1].cap += k; rest -= k; } } if (flow - rest &lt; flow) dep[u] = -1; return flow - rest;}inline void solve(){ int now = 0; while (bfs()) while ((now = dinic(s, inf))) ans += now;}int main(){ int x, tmp = 0; m = read(), n = read(); for (int i = 1; i &lt;= m; i++) x = read(), add_edge(s, i, x), tmp += x; for (int i = 1; i &lt;= n; i++) x = read(), add_edge(i + m, t, x); for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= n; j++) add_edge(i, j + m, 1); } solve(); if (ans != tmp) return 0 * printf(\"0\"); printf(\"1\\n\"); for (int i = 1; i &lt;= m; i++) { int h = head[i]; while (h) { if (!e[h].cap) printf(\"%d \", e[h].to - m); h = e[h].next; } puts(\"\"); } return 0;}","link":"/2019/05/09/LOJ-6004/"},{"title":"LOJ 6006「网络流 24 题」试题库","text":"和LOJ #6004圆桌聚餐很像 建模： 1.从源点向每道试题$x_i$连一条容量为$1$的边 2.从每种类型$y_i$向汇点连一条容量为该类型需求数量的边 3.如果试题$x_i$属于类型$y_i$则从$x_i$向$y_i$连一条容量为$1$的边 然后跑裸的网络最大流，如果最大流$\\not=$需求试题总数则无解 方案： 对于每种类型，它连出的所有满流量边即为该类型所对应的试题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define cmax(a, b) ((a &lt; b) ? b : a)#define cmin(a, b) ((a &lt; b) ? a : b)#define sum(a, b, mod) ((a + b) % mod)const int MaxN = 2e4 + 10;const int MaxM = 5e5 + 10;const int inf = (1 &lt;&lt; 30);struct edge{ int to, next, cap;};edge e[MaxM];int k, n, s = 20000, t = 20001, cnt = 1, ans;int head[MaxN], dep[MaxN], cur[MaxN], a[MaxN];inline void add(int u, int v, int c){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; e[cnt].cap = c; head[u] = cnt;}inline void add_edge(int u, int v, int c) { add(u, v, c), add(v, u, 0); }inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline int bfs(){ memset(dep, 0, sizeof(dep)); memcpy(cur, head, sizeof(head)); std::queue&lt;int&gt; q; dep[s] = 1; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i; i = e[i].next) { int v = e[i].to, c = e[i].cap; if (dep[v] || !c) continue; dep[v] = dep[u] + 1; q.push(v); } } return dep[t];}inline int dinic(int u, int flow){ if (u == t) return flow; int rest = flow; for (int i = cur[u]; i &amp;&amp; (flow - rest &lt; flow); i = e[i].next) { int v = e[i].to, c = e[i].cap; if (dep[v] != dep[u] + 1 || !c) continue; int k = dinic(v, cmin(rest, c)); if (!k) dep[v] = dep[u] + 1; else { e[i].cap -= k; e[i ^ 1].cap += k; rest -= k; } } if (flow - rest &lt; flow) dep[u] = -1; return flow - rest;}inline void solve(){ int now = 0; while (bfs()) while ((now = dinic(s, inf))) ans += now;}int main(){ int tmp = 0; k = read(), n = read(); for (int i = 1; i &lt;= k; i++) { int x = read(); add_edge(i, t, x); tmp += x; } for (int i = 1; i &lt;= n; i++) { int p = read(); add_edge(s, i + k, 1); for (int j = 1; j &lt;= p; j++) { int x = read(); add_edge(i + k, x, 1); } } solve(); if (ans != tmp) return 0 * printf(\"No Solution!\"); for (int i = 1; i &lt;= k; i++) { int t = head[i]; printf(\"%d: \", i); while (t) { if (e[t].cap == 1) printf(\"%d \", e[t].to - k); t = e[t].next; } printf(\"\\n\"); } return 0;}","link":"/2019/05/11/LOJ-6006/"},{"title":"LOJ 6012「网络流 24 题」分配问题","text":"zcy费用流第一题！ 建模： 1.从$s$向人$1-n$连边，容量为$1$,费用为$0$ 2.从工作$1-n$向$t$连边，容量为$1$,费用为$0$ 3.从人$1-n$向工作$1-n$连边，容量为$1$，费用为$c_{i,j}$ 然后我们就可以跑裸的费用流啦~ 什么？你问我最大费用怎么写？当然是把边权取反啊 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define cmax(a, b) ((a &lt; b) ? b : a)#define cmin(a, b) ((a &lt; b) ? a : b)#define sum(a, b, mod) ((a + b) % mod)const int MaxN = 5e3 + 10;const int MaxM = 5e4 + 10;struct edge{ int next, to, flow, cost;};edge e[MaxM];int n, s = 600, t = 601, ans, cnt = 1, mincost, maxflow;int head[MaxN], flow[MaxN], dis[MaxN], pre[MaxN], last[MaxN], vis[MaxN], a[210][210];inline void add(int u, int v, int f, int c){ ++cnt; e[cnt].to = v; e[cnt].flow = f; e[cnt].cost = c; e[cnt].next = head[u]; head[u] = cnt;}inline void add_edge(int u, int v, int f, int c){ add(u, v, f, c); add(v, u, 0, -c);}inline int read(){ int x = 0, f = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') { if (ch == '-') f = 0; ch = getchar(); } while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return f ? x : (-x);}int spfa(){ memset(dis, 0x3f, sizeof(dis)); memset(flow, 0x3f, sizeof(flow)); memset(vis, 0, sizeof(vis)); std::queue&lt;int&gt; q; q.push(s); vis[s] = 1; dis[s] = 0; pre[t] = -1; while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = head[u]; i; i = e[i].next) { if (e[i].flow &amp;&amp; dis[e[i].to] &gt; dis[u] + e[i].cost) { int v = e[i].to; dis[v] = dis[u] + e[i].cost; pre[v] = u; last[v] = i; flow[v] = cmin(flow[u], e[i].flow); if (!vis[v]) { vis[v] = 1; q.push(v); } } } } return pre[t] != -1;}void MCMF(){ while (spfa()) { int u = t; maxflow += flow[t]; mincost += flow[t] * dis[t]; while (u != s) { e[last[u]].flow -= flow[t]; e[last[u] ^ 1].flow += flow[t]; u = pre[u]; } }}int main(){ n = read(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) a[i][j] = read(); for (int i = 1; i &lt;= n; i++) add_edge(s, i, 1, 0), add_edge(i + n, t, 1, 0); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) add_edge(i, j + n, 1, a[i][j]); MCMF(); cnt = 1; printf(\"%d\\n\", mincost); memset(head, 0, sizeof(head)); memset(pre, 0, sizeof(pre)); memset(last, 0, sizeof(last)); maxflow = mincost = 0; for (int i = 1; i &lt;= n; i++) add_edge(s, i, 1, 0), add_edge(i + n, t, 1, 0); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) add_edge(i, j + n, 1, -a[i][j]); MCMF(); printf(\"%d\", -mincost); return 0;}","link":"/2019/05/21/LOJ-6012/"},{"title":"UVA10228 A Star not a Tree?","text":"题目大意给定$n$个点, 求一个点使得这个点到所有$n$个点的距离最小，输出距离（保留整数） 题解计算几何什么的我不会o((⊙﹏⊙))o 那我们就来随机化吧(￣▽￣)~* 按照模拟退火的套路来：每次随机一个点，判他是不是比答案更优，如果更优的话就更新，否则就以一定的几率接受该解。直到稳定在最优解为止。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;const int MaxN = 200;const double delta = 0.995;int n;int x[MaxN], y[MaxN];double ansx, ansy;inline double calc(double nx, double ny){ double tmp = 0; for (int i = 1; i &lt;= n; i++) tmp += sqrt((nx - x[i]) * (nx - x[i]) + (ny - y[i]) * (ny - y[i])); return tmp;}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline void sa(){ double t = 10000000; while (t &gt; 1e-14) { double nowx = ansx + (rand() * 2 - RAND_MAX) * t; double nowy = ansy + (rand() * 2 - RAND_MAX) * t; double tmp = calc(nowx, nowy) - calc(ansx, ansy); if (tmp &lt; 0) ansx = nowx, ansy = nowy; else if (exp(-tmp / t) * RAND_MAX &gt; rand()) ansx = nowx, ansy = nowy; t *= delta; }}int main(){ srand(time(NULL)); int T = read(); while (T--) { ansx = ansy = 0; n = read(); for (int i = 1; i &lt;= n; i++) x[i] = read(), y[i] = read(); for (int i = 1; i &lt;= 100; i++) sa(); printf(\"%.0lf\\n\", calc(ansx, ansy)); if(T) printf(\"\\n\"); } return 0;}","link":"/2019/02/08/uva10228/"},{"title":"<模板> MillerRabin","text":"提交地址: LOJ #143. 质数判定 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define ll long longconst int cnt = 2500;const int mod[] = {3, 5, 7, 11, 13, 17, 19, 23, 29};ll fast_mul(ll a, ll b, ll m){ ll d = ((long double)a / m * b + 0.5); ll r = a * b - d * m; return r &lt; 0 ? r + m : r;}ll fast_pow(ll a, ll m, ll n){ ll ret = 1; while (m) { if (m &amp; 1) ret = fast_mul(ret, a, n); a = fast_mul(a, a, n); m &gt;&gt;= 1; } return ret;}bool check(ll k){ if (k &lt;= 1) return false; if (k == 2) return true; if (!(k &amp; 1)) return false; ll t = k - 1; int now = 0; while (!(t &amp; 1)) t &gt;&gt;= 1, ++now; for (int i = 0; i &lt; 9; i++) { if (mod[i] == k) return 1; ll x = fast_pow(mod[i], t, k), y = x; for (int j = 1; j &lt;= now; j++) { x = fast_mul(x, x, k); if (x == 1 &amp;&amp; !(y == 1 || y == k - 1)) return false; y = x; } if (x != 1) return 0; } return true;}int main(){ srand(time(NULL)); ll k; while (scanf(\"%llu\", &amp;k) == 1) printf(check(k) ? \"Y\\n\" : \"N\\n\"); return 0;}","link":"/2019/04/05/模板-millerrabin/"},{"title":"洛谷2210 Haywire","text":"模拟退火模板题… 每次随机将两个位置上的奶牛交换位置 然后算出现在所需的干草数量 如果比答案少就更新 否则就以一定概率接受这个解 然后。。多随机几次就做完了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define cmin(a, b) ((a &lt; b) ? a : b)#define cmax(a, b) ((a &lt; b) ? b : a)const double delta = 0.999;const int MaxN = 20;int n, ans = 0x3f3f3f3f;double t = 10000000.0;int pos[MaxN], fri[MaxN][4], g[MaxN][MaxN];inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline int calc(){ int ret = 0; for (int i = 1; i &lt;= n; i++) { ret += abs(pos[i] - pos[fri[i][1]]); ret += abs(pos[i] - pos[fri[i][2]]); ret += abs(pos[i] - pos[fri[i][3]]); } return ret / 2;}inline void SA(){ t = 1.0; while (t &gt; 1e-10) { int x = rand() % n + 1, y = rand() % n + 1; std::swap(pos[x], pos[y]); int tmp = calc(); int del = tmp - ans; if (del &lt; 0) ans = tmp; else if (exp(-del / t) * RAND_MAX &lt;= rand()) std::swap(pos[x], pos[y]); t *= delta; }}int main(){ n = read(); srand(time(NULL)); for (int i = 1; i &lt;= n; i++) { pos[i] = i; for (int j = 1; j &lt;= 3; j++) fri[i][j] = read(), g[i][fri[i][j]] = 1, g[fri[i][j]][i] = 1; } for (int i = 1; i &lt;= 100; i++) SA(); printf(\"%d\\n\", ans); return 0;} 不要问我为什么这么久没更博客","link":"/2019/03/30/洛谷2210/"},{"title":"洛谷1156 垃圾陷阱","text":"一道简单的动态规划 将每个垃圾按扔下来的时间从小到大排序 每次扔下来一个垃圾时，如果能靠这个垃圾爬出来就123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051不然就继续最后如果挂了的话算一下他能撑多久```cpp#include &lt;bits/stdc++.h&gt;const int MaxN = 100010;struct node{ int t, f, h;};node a[MaxN];int d, g, f[MaxN];inline int cmp(node a, node b){ return a.t &lt; b.t;}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; &apos;9&apos; || ch &lt; &apos;0&apos;) ch = getchar(); while (ch &lt;= &apos;9&apos; &amp;&amp; ch &gt;= &apos;0&apos;) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}int main(){ d = read(), g = read(); for (int i = 1; i &lt;= g; i++) a[i].t = read(), a[i].f = read(), a[i].h = read(); std::sort(a + 1, a + g + 1, cmp); f[0] = 10; for (int i = 1; i &lt;= g; i++) { for (int j = d; j &gt;= 0; j--) { if (f[j] &gt;= a[i].t) { if (j + a[i].h &gt;= d) return 0 * printf(&quot;%d\\n&quot;, a[i].t); f[j + a[i].h] = std::max(f[j], f[j + a[i].h]); f[j] += a[i].f; } } } printf(&quot;%d\\n&quot;, f[0]); return 0;}","link":"/2019/02/24/洛谷1156/"},{"title":"洛谷 P1337 [JSOI2004]平衡点 / 吊打XXX","text":"一些模拟退火的注意事项： 开始温度要设到比较高 在不超时的情况下多随几次 最好确定一个随机种子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;const int MaxN = 1010;const double delta = 0.993;struct node{ int x, y, w;};int n;node a[MaxN];double ansx, ansy;double ans = 1e18, t;inline int read(){ bool f = 0; int x = 0; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') { if (ch == '-') f = true; ch = getchar(); } while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = getchar(); return (!f) ? x : -x;}double calc(double nx, double ny){ double sum = 0; for (int i = 1; i &lt;= n; i++) { double x = nx - a[i].x; double y = ny - a[i].y; sum += sqrt(x * x + y * y) * a[i].w; } return sum;}void sa(){ double nowx = ansx, nowy = ansy; t = 1000000; while (t &gt; 1e-14) { double tmpx = ansx + (rand() * 2 - RAND_MAX) * t; double tmpy = ansy + (rand() * 2 - RAND_MAX) * t; double tmp = calc(tmpx, tmpy); if (tmp - ans &lt; 0) { nowx = tmpx; nowy = tmpy; ansx = tmpx; ansy = tmpy; ans = tmp; } else if (exp((ans - tmp) / t) * RAND_MAX &gt; rand()) { nowx = tmpx; nowy = tmpy; } t *= delta; }}int main(){ n = read(); srand(19260817); for (int i = 1; i &lt;= n; i++) a[i].x = read(), a[i].y = read(), a[i].w = read(); sa(); printf(\"%.3lf %.3lf\", ansx, ansy); return 0;}","link":"/2019/02/06/洛谷1337/"},{"title":"洛谷 P2503 [HAOI2006]均分数据","text":"模拟退火写起来真舒服喵~ 首先我们把这$n$个数随机分成$m$组，然后退火时每次随机两个数交换分组，如果更优的话就保存，不然的话就以一定的概率接受该答案 记得多随机几次喵~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;const int MaxN = 50;const double delta = 0.995;int n, m;int a[MaxN], f[MaxN];double sum[MaxN], aver = 0, ans = 1e18;inline int read(){ int x = 0, f = 1; char ch = getchar(); while(ch &gt; '9' || ch &lt; '0') { if(ch == '-') f = 0; ch = getchar(); } while(ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return f ? x : (-x);}inline double calc(){ double tmp = 0; for (int i = 1; i &lt;= m; i++) tmp += (sum[i] - aver) * (sum[i] - aver); return tmp;}void sa(){ memset(sum, 0, sizeof(sum)); double tmp = 0; for(int i = 1; i &lt;= n; i++) f[i] = rand() % m + 1, sum[f[i]] += a[i]; for(int i = 1; i &lt;= m; i++) tmp += (sum[i] - aver) * (sum[i] - aver); double t = 10000000; while(t &gt; 1e-14) { int x = rand() % n + 1, y = rand() % n + 1; while(f[x] == f[y]) x = rand() % n + 1, y = rand() % n + 1; sum[f[x]] -= a[x]; sum[f[x]] += a[y]; sum[f[y]] += a[x]; sum[f[y]] -= a[y]; double now = calc(); if ((now &lt; tmp) || (exp((now - tmp) / t) * RAND_MAX &lt; rand())) tmp = now, std::swap(f[x], f[y]); else sum[f[x]] += (a[x] - a[y]), sum[f[y]] += (a[y] - a[x]); t *= delta; } if(tmp &lt; ans) ans = tmp;}int main(){ srand(time(NULL)); n = read(), m = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(), aver += a[i]; aver /= m; for(int i = 1; i &lt;= 500; i++) sa(); printf(\"%.2lf\", sqrt(ans / m)); return 0;}","link":"/2019/02/07/洛谷2503/"},{"title":"洛谷 P2485 【[SDOI2011]计算器】","text":"数论三合一大礼包第一问快速幂不讲了 第二问要你求的是$x*y \\equiv z \\mod p$ 即 $xy - kp = z$ 即 $xy + p*(-k) = z$ 就转换为$exgcd$的标准形式了（这个相信大家都会吧） 第三问BSGS模板题 有兴趣可以看P4195 exBSGS模板 注意$b$有可能大于$p$，所以要膜一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;#define ll long long#define int llstd::unordered_map&lt;int, int&gt; h;int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }inline int mul(int a, int b, int p){ ll ret = 0; while(b) { if (b &amp; 1) ret = (ret + a) % p; a = (a + a) % p; b &gt;&gt;= 1; } return ret;}void exgcd(int a, int b, int &amp;x, int &amp;y){ if (b == 0) { x = 1, y = 0; return; } exgcd(b, a % b, x, y); int t = x; x = y, y = t - (a / b) * y;}int solve1(int a, int b, int p){ ll ret = 1; while (b) { if (b &amp; 1) ret = mul(ret, a, p); a = mul(a, a, p); b &gt;&gt;= 1; } return ret;}int solve2(int a, int b, int p){ int x = 0, y = 0; int g = gcd(a, p); if (b % g) return -1; exgcd(a, p, x, y); x *= (b / g); x = (x % p + p) % p; return x;}int solve3(int a, int b, int p){ if (b == 1) return 0; int cnt = 0, d, k = 1; while ((d = gcd(a, p)) ^ 1) { if (b % d) return -1; b /= d, p /= d, ++cnt; k = mul(k, a / d, p); if (k == b) return cnt; } int t = sqrt(p) + 1, tmp = 1; h.clear(); for (int i = 0; i &lt; t; i++) { h[mul(tmp, b, p)] = i; tmp = mul(tmp, a, p); } k = mul(k, tmp, p); for (int i = 1; i &lt;= t; i++) { if (h.find(k) != h.end()) return i * t - h[k] + cnt; k = mul(k, tmp, p); } return -1;}signed main(){ int T, op; scanf(\"%lld%lld\", &amp;T, &amp;op); while (T--) { int a, b, p; scanf(\"%lld%lld%lld\", &amp;a, &amp;b, &amp;p); if (op == 1) printf(\"%lld\\n\", solve1(a, b, p)); if (op == 2) { b %= p; int ans = solve2(a, b, p); if (ans == -1) printf(\"Orz, I cannot find x!\\n\"); else printf(\"%lld\\n\", ans); } if (op == 3) { b %= p;//注意这个！ int ans = solve3(a, b, p); if (ans == -1) printf(\"Orz, I cannot find x!\\n\"); else printf(\"%lld\\n\", ans); } } return 0;}","link":"/2019/02/06/洛谷2485/"},{"title":"<模板> 树套树","text":"提交地址: 洛谷P3380 二逼平衡树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221#include &lt;bits/stdc++.h&gt;#define reg register#define lc t[x].ch[0]#define rc t[x].ch[1]using namespace std;const int MaxN = 50010;const int inf = 2147483647;int n, m, tot;int a[MaxN];struct node{ int ch[2]; int cnt, size, val, rnd;};node t[MaxN &lt;&lt; 5];struct treap{ int l, r, root; void update(int x) { t[x].size = t[lc].size + t[rc].size + t[x].cnt; } void rotate(int &amp;x, int c) { int s = t[x].ch[c]; t[x].ch[c] = t[s].ch[c ^ 1]; t[s].ch[c ^ 1] = x; update(x); update(x = s); } void insert(int &amp;x, int val) { if (!x) { x = ++tot; t[x].cnt = t[x].size = 1; t[x].rnd = rand(), t[x].val = val; return; } t[x].size++; if (t[x].val == val) { ++t[x].cnt; return; } int c = val &gt; t[x].val; insert(t[x].ch[c], val); if (t[x].rnd &gt; t[t[x].ch[c]].rnd) rotate(x, c); } void del(int &amp;x, int val) { if (!x) return; if (t[x].val == val) { if (t[x].cnt &gt; 1) { t[x].cnt--, t[x].size--; return; } bool c = t[lc].rnd &gt; t[rc].rnd; if (lc == 0 || rc == 0) x = lc + rc; else rotate(x, c), del(x, val); } else --t[x].size, del(t[x].ch[t[x].val &lt; val], val); } int rank(int x, int val) { if (!x) return 0; if (t[x].val == val) return t[lc].size; if (t[x].val &gt; val) return rank(lc, val); else return t[lc].size + t[x].cnt + rank(rc, val); } int query_val(int x, int val) { while (1) { if (val &lt;= t[lc].size) x = lc; else if (val &gt; t[lc].size + t[x].cnt) val -= t[lc].size + t[x].cnt, x = rc; else return t[x].val; } } int query_pre(int x, int val) { if (!x) return -inf; if (t[x].val &gt;= val) return query_pre(lc, val); else return cmax(t[x].val, query_pre(rc, val)); } int query_sub(int x, int val) { if (!x) return inf; if (t[x].val &lt;= val) return query_sub(rc, val); else return cmin(t[x].val, query_sub(lc, val)); }};treap tr[MaxN &lt;&lt; 2];struct tree{ void build(int id, int l, int r) { tr[id].l = l, tr[id].r = r; for (int i = l; i &lt;= r; i++) tr[id].insert(tr[id].root, a[i]); if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); } int query_rank(int id, int l, int r, int val) { if (tr[id].l &gt; r || tr[id].r &lt; l) return 0; if (l &lt;= tr[id].l &amp;&amp; tr[id].r &lt;= r) { int ans = tr[id].rank(tr[id].root, val); return ans; } int ans = 0; ans += query_rank(id &lt;&lt; 1, l, r, val); ans += query_rank(id &lt;&lt; 1 | 1, l, r, val); return ans; } int query_val(int l, int r, int k) { int L = 0, R = 1e8; while (L &lt; R) { int mid = (L + R + 1) &gt;&gt; 1; if (query_rank(1, l, r, mid) + 1 &lt;= k) L = mid; else R = mid - 1; } return L; } void modify(int id, int pos, int val) { if (pos &lt; tr[id].l || tr[id].r &lt; pos) return; tr[id].del(tr[id].root, a[pos]); tr[id].insert(tr[id].root, val); if (tr[id].l == tr[id].r) return; modify(id &lt;&lt; 1, pos, val); modify(id &lt;&lt; 1 | 1, pos, val); } int query_pre(int id, int l, int r, int val) { if (tr[id].l &gt; r || tr[id].r &lt; l) return -inf; if (l &lt;= tr[id].l &amp;&amp; tr[id].r &lt;= r) return tr[id].query_pre(tr[id].root, val); int ans = max(query_pre(id &lt;&lt; 1, l, r, val), query_pre(id &lt;&lt; 1 | 1, l, r, val)); return ans; } int query_sub(int id, int l, int r, int val) { if (tr[id].l &gt; r || tr[id].r &lt; l) return inf; if (l &lt;= tr[id].l &amp;&amp; tr[id].r &lt;= r) return tr[id].query_sub(tr[id].root, val); int ans = min(query_sub(id &lt;&lt; 1, l, r, val), query_sub(id &lt;&lt; 1 | 1, l, r, val)); return ans; }} T;inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}int main(){ srand(19260817); int n = read(), m = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); int op; T.build(1, 1, n); for (int i = 1; i &lt;= m; i++) { op = read(); int l, r, val, pos; if (op == 3) { pos = read(), val = read(); T.modify(1, pos, val); a[pos] = val; continue; } l = read(), r = read(), val = read(); if (op == 1) printf(\"%d\\n\", T.query_rank(1, l, r, val) + 1); else if (op == 2) printf(\"%d\\n\", T.query_val(l, r, val)); else if (op == 4) printf(\"%d\\n\", T.query_pre(1, l, r, val)); else if (op == 5) printf(\"%d\\n\", T.query_sub(1, l, r, val)); } return 0;}","link":"/2019/04/05/模板-树套树/"},{"title":"洛谷2048 [NOI2010] 超级钢琴","text":"题目大意你有一个序列${a_i}$，你要找出$k$个不相同的区间$[l_i,r_i]$，使得这些区间的和最大。 求这个最大值 分析我们发现这个题有点像$\\texttt{P2085 最小函数值}$，我们考虑用一样的方法做 显然，对于这个序列，$i \\in [1, n - l + 1]$的$a_i$都可以作为左端点，我们考虑建立一个堆，堆里放置以每个点为左端点的区间 堆里的节点可以记为$\\texttt{(L, R, maxp, val, pos)}$其中$\\texttt{L, R}$分别表示当前区间的长度的上下界，$\\texttt{pos}$表示该区间的左端点，$\\texttt{maxp}$表示以$\\texttt{pos}$为左端点且长度$\\in \\texttt{[L,R]}$的和最大的区间长度，$\\texttt{val}$表示$[i, i + maxp - 1]$这个区间的和 初始把所有左端点$i$对应的区间$[i,i+l-1]$到$[i,min(i+r-1,n)]$的和最大的区间加入堆中 每次我们取出堆中和最大的区间，设这个区间为$\\texttt{(L, R, maxp, val, pos)}$ 则我们把$\\texttt{val}$记录进答案，并往堆里插入$\\texttt{(L, maxp-1, maxp’, val’, pos)}$和$\\texttt{(maxp+1, R, maxp’’, val’’, pos)}$ 这里$\\texttt{maxp’,val’,maxp’’,val’’}$分别表示左右半区间的最大和取到的位置和这个最大和 将这个操作执行$k$次，时间复杂度$\\texttt{O(n log n)}$ PS. 维护区间的最大值和最大值位置可以用$\\texttt{ST}$表维护 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;#define ll long long#define sum(a, b, mod) (((a) + (b)) % mod)const ll MaxN = 5e5 + 10;struct node{ ll maxp, val; ll l, r, pos; bool operator&lt;(node x) const { return val &lt; x.val; }};ll n, k, l, r;std::priority_queue&lt;node&gt; q;ll a[MaxN], lg[MaxN], sum[MaxN], max[MaxN][21], maxp[MaxN][21];void query(ll l, ll r, ll &amp;val, ll &amp;pos){ ll len = lg[r - l + 1]; val = std::max(max[l][len], max[r - (1 &lt;&lt; len) + 1][len]); pos = (max[l][len] &gt; max[r - (1 &lt;&lt; len) + 1][len]) ? maxp[l][len] : maxp[r - (1 &lt;&lt; len) + 1][len];}void prework(){ lg[0] = -1; for (ll i = 1; i &lt;= n; i++) maxp[i][0] = i, max[i][0] = sum[i], lg[i] = lg[i &gt;&gt; 1] + 1; for (ll j = 1; j &lt;= 20; j++) for (ll i = 1; i &lt;= n - (1 &lt;&lt; j) + 1; i++) max[i][j] = std::max(max[i][j - 1], max[i + (1 &lt;&lt; (j - 1))][j - 1]); for (ll j = 1; j &lt;= 20; j++) for (ll i = 1; i &lt;= n - (1 &lt;&lt; j) + 1; i++) maxp[i][j] = ((max[i][j - 1] &gt; max[i + (1 &lt;&lt; (j - 1))][j - 1]) ? maxp[i][j - 1] : maxp[i + (1 &lt;&lt; (j - 1))][j - 1]);}inline ll read(){ ll x = 0, f = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') { if (ch == '-') f = 0; ch = getchar(); } while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return f ? x : (-x);}int main(){ n = read(), k = read(); l = read(), r = read(); for (ll i = 1; i &lt;= n; i++) a[i] = read(), sum[i] = sum[i - 1] + a[i]; prework(); for (ll i = 1; i &lt;= n; i++) { ll pos, val; if (i + l - 1 &gt; n) break; query(i + l - 1, std::min(i + r - 1, n), val, pos); val -= sum[i - 1], pos -= i - 1; q.push((node){pos, val, l, std::min(r, n - i + 1), i}); } ll ans = 0; for(ll i = 1; i &lt;= k; i++) { node x = q.top(); q.pop(), ans += x.val; if(x.maxp &gt; x.l) { ll pos, val; query(x.pos + x.l - 1, x.pos + x.maxp - 2, val, pos); val -= sum[x.pos - 1], pos -= x.pos - 1; q.push((node){pos, val, x.l, x.maxp - 1, x.pos}); } if(x.maxp &lt; x.r) { ll pos, val; query(x.pos + x.maxp, x.pos + x.r - 1, val, pos); val -= sum[x.pos - 1], pos -= x.pos - 1; q.push((node){pos, val, x.maxp + 1, x.r, x.pos}); } } printf(\"%lld\\n\", ans); return 0;}","link":"/2020/03/09/洛谷2048/"},{"title":"洛谷3628 [APIO2010]特别行动队","text":"斜率优化的练手题 通读题目可以发现$$f_i=\\max (f_j+g(s[i]-s[j]))$$ $$其中f_i表示在i处强制结束一段的最大代价,s_i表示a_i的前缀和,g(x)表示(ax^2+bx+c)$$ 展开这个式子我们得到$$f_i=\\max(f_j+as_i^2-2as_is_j+as_j^2+bs_i-bs_j+c)$$去掉$\\max$，移项得到:$$(f_j+as_j^2-bs_j)=2as_is_j+(f_i-as_i^2-bs_i-c)$$ 然后就是常规的单调队列维护上凸壳了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define sum(a, b, mod) (((a) + (b)) % mod)const int MaxN = 1e6 + 10;ll n, A, B, C;ll a[MaxN], s[MaxN], f[MaxN], q[MaxN];inline ll read(){ ll x = 0, f = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') { if (ch == '-') f = 0; ch = getchar(); } while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return f ? x : (-x);}ll g(int num) { return A * num * num + B * num + C; }ll x(int num) { return s[num]; }ll y(int num) { return (f[num] + A * s[num] * s[num] - B * s[num]); }ll k(int num) { return 2 * A * s[num]; }int main(){ n = read(), A = read(), B = read(), C = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(), s[i] = s[i - 1] + a[i]; int l = 1, r = 1; for (int i = 1; i &lt;= n; i++) { while (l &lt; r &amp;&amp; (y(q[l + 1]) - y(q[l])) &gt;= k(i) * (x(q[l + 1]) - x(q[l]))) ++l; f[i] = f[q[l]] + g(s[i] - s[q[l]]); while (l &lt; r &amp;&amp; (y(q[r]) - y(q[r - 1])) * (x(i) - x(q[r])) &lt;= (y(i) - y(q[r])) * (x(q[r]) - x(q[r - 1]))) --r; q[++r] = i; } printf(\"%lld\\n\", f[n]); return 0;}","link":"/2019/11/30/洛谷3628/"},{"title":"洛谷 P3878 [TJOI2010]分金币","text":"题目大意将$n$个数分成两半，使得这两半的差尽量小 Solution我们首先先把这$n$个数按下标顺序分成两组，然后每次随机选取前半段和后半段的两个数将其交换，如果更优的话就更新$ans$,否则就以$e^{\\frac{-de}{t}}$（$de=$当前解-最优解）的概率接受该交换(其实就是模拟退火的基本套路) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define ll long longconst int MaxN = 50;const double delta = 0.993;ll n, a[MaxN], ans;ll abs(ll x){ return (x &gt; 0) ? x : (-x);}inline ll calc(){ ll sum1 = 0, sum2 = 0; for (int i = 1; i &lt;= n; i++) { if(i &lt;= (n + 1) / 2) sum1 += a[i]; else sum2 += a[i]; } return abs(sum1 - sum2);}inline void sa(){ double t = 10000000; while (t &gt; 1e-14) { int x = rand() % ((n + 1) / 2) + 1, y = rand() % ((n + 1) / 2) + ((n + 1) / 2); std::swap(a[x], a[y]); int now = calc(); int de = now - ans; if (de &lt; 0) ans = now; else if (exp(-de / t) * RAND_MAX &lt;= rand()) std::swap(a[x], a[y]); t *= delta; }}int main(){ int T; srand(time(NULL)); scanf(\"%d\", &amp;T); while (T--) { scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%lld\", &amp;a[i]); ans = 1e9; for (int i = 1; i &lt;= 50; i++) sa(); printf(\"%lld\\n\", ans); } return 0;}","link":"/2019/02/10/洛谷3878/"},{"title":"「洛谷 P3674」 小清新人渣的本愿","text":"莫队+$bitset$优化 操作$1$： 维护一个$bitset:$ $cnt1$.$cnt1_i$表示$i$这个数是否出现 若存在数$y,z$使得$y-z=x$,则$y = z + x$ 故将$cnt1$与($cnt1&lt;&lt;x$)做与运算即可 操作$2​$： 维护两个$bitset: cnt1,cnt2$. $cnt1_i$表示$i$这个数是否出现,$cnt2_i$表示$MaxN-i$这个数是否出现 若存在数$y,z$使得$y+z=x$,则有$y + z - MaxN= x - MaxN$ 令$z’=MaxN-z$，则原式转化为$y - z’ = x - MaxN$ 那么就变成了操作1了。。。只不过这次在cnt2中查$z’$ 故将$cnt1$与$(cnt2&gt;&gt;($MaxN-x$))$做与运算即可(为什么右移$MaxN-x$位呢？因为cnt2和cnt1是反着存储的) 操作$3$： 暴力枚举$x$的约数查询即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;const int MaxN = 100010;struct query{ int id, pos; int op, l, r, x;};query q[MaxN];int n, m, size;int a[MaxN], cnt[MaxN], ans[MaxN];std::bitset&lt;100010&gt; cnt1, cnt2;inline int cmp(query a, query b){ if (a.pos != b.pos) return a.pos &lt; b.pos; else return a.r &lt; b.r;}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline void add(int x){ ++cnt[a[x]]; if(cnt[a[x]] == 1) cnt1[a[x]] = 1, cnt2[100000 - a[x]] = 1;}inline void del(int x){ --cnt[a[x]]; if(cnt[a[x]] == 0) cnt1[a[x]] = 0, cnt2[100000 - a[x]] = 0;}inline void solve(){ int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) { while (l &gt; q[i].l) --l, add(l); while (r &lt; q[i].r) ++r, add(r); while (l &lt; q[i].l) del(l), ++l; while (r &gt; q[i].r) del(r), --r; if (q[i].op == 1) ans[q[i].id] = (cnt1 &amp; (cnt1 &lt;&lt; q[i].x)).any(); else if (q[i].op == 2) ans[q[i].id] = (cnt1 &amp; (cnt2 &gt;&gt; (100000 - q[i].x))).any(); else if (q[i].op == 3) { for (int j = 1; j * j &lt;= q[i].x; j++) { if (q[i].x % j == 0) if (cnt1[j] &amp;&amp; cnt1[q[i].x / j]) ans[q[i].id] = 1; } } }}int main(){ n = read(), m = read(); size = pow(n, 0.55); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt;= n; i++) { q[i].op = read(), q[i].l = read(), q[i].r = read(), q[i].x = read(); q[i].id = i, q[i].pos = (q[i].l - 1) / size + 1; } std::sort(q + 1, q + m + 1, cmp); solve(); for (int i = 1; i &lt;= m; i++) puts(ans[i] == 1 ? \"hana\" : \"bi\"); return 0;}","link":"/2019/02/12/洛谷3674/"},{"title":"洛谷3959 [NOIP2017]宝藏","text":"题目大意给你$n$个点,$m$条边,要你选一个点作为根建一棵生成树满足代价最小 一棵生成树的代价是$\\Sigma \\; dep[i] * dis[fa_i][i]$, 其中$dep_i$表示$i$节点在这棵生成树中的深度（根节点深度为$0$,$dis[fa_i][i]$表示$i$节点到他父亲节点的距离 题目解析首先通过$n\\leq12$可以发现这是一道状压dp/搜索题 这里我们考虑状压dp 我们设状态$f[i]$表示选点的状态为$i$时,这棵生成树的最小代价,$st_{i,j}$表示当选点状态为$i$且$i$状态取最优方案时节点$j$的深度 那么我们可以很快想到一个dp方程 $$f_{i|2^k}=\\min{f_{i|2^k}, f_i+(g[j][k]*(st[i][j]+1))}, st_{i|2^k, k}=st_{i,j}+1(j \\in i \\;\\mathrm{and}\\;k \\notin i)\\$$ 初始值满足$f_{2^s}=0,st_{2^s,s}=0$,其余位置的$f$和$st$都为$\\mathrm{inf}$ 这个方程的复杂度是$O(n^2 \\times 2^n)$的 注意到根不是固定的, 所以我们可以每次选定一个根来进行dp的计算，总复杂度$O(n^3\\times2^n)$ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define sum(a, b, mod) (((a) + (b)) % mod)const int MaxN = 13;int n, m;int g[MaxN][MaxN], st[1 &lt;&lt; MaxN][MaxN], f[1 &lt;&lt; MaxN];int dp(int s){ memset(st, 0x3f, sizeof(st)), memset(f, 0x3f, sizeof(f)); int lim = (1 &lt;&lt; n); f[1 &lt;&lt; s] = 0, st[1 &lt;&lt; s][s] = 0; for (int i = 1; i &lt; lim; i++) { if (f[i] &lt; 0x3f3f3f3f) { for (int j = 0; j &lt; n; j++) { if (i &amp; (1 &lt;&lt; j)) { for (int k = 0; k &lt; n; k++) { if (!(i &amp; (1 &lt;&lt; k))) { if ((g[j][k] != 0x3f3f3f3f) &amp;&amp; (f[i | (1 &lt;&lt; k)] &gt; f[i] + (g[j][k] * (st[i][j] + 1)))) { f[i | (1 &lt;&lt; k)] = f[i] + (g[j][k] * (st[i][j] + 1)); memcpy(st[i | (1 &lt;&lt; k)], st[i], sizeof(st[i | (1 &lt;&lt; k)])); st[i | (1 &lt;&lt; k)][k] = st[i][j] + 1; } } } } } } } return f[lim - 1];}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); memset(g, 0x3f, sizeof(g)); for (int i = 1; i &lt;= m; i++) { int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d), --u, --v; g[u][v] = std::min(g[u][v], d), g[v][u] = std::min(g[v][u], d); } int ans = 0x3f3f3f3f; for (int i = 0; i &lt; n; i++) ans = std::min(ans, dp(i)); printf(\"%d\\n\", ans); return 0;}","link":"/2019/11/03/洛谷3959/"},{"title":"洛谷 P3936 Coloring","text":"思路其实很容易想到，只是调参有那么”一点点”恶心 首先按顺序把$1-c$这$c$种数全部填进表格里 然后每次随机选两个颜色不同的块交换，然后计算原方案与现方案的差距，并按几率更新 代码五分钟，调参两百年:C 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(3)using namespace std;const int MaxN = 30;const int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};int n, m, c;int p[51];int a[MaxN][MaxN], tmp[MaxN][MaxN];inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline int calc(int A[30][30]){ int ret = 0; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { for (int k = 0; k &lt;= 3; k++) { int nx = i + dx[k], ny = j + dy[k]; if (A[nx][ny] &amp;&amp; (A[nx][ny] != A[i][j])) ++ret; } } } return ret / 2;}inline void init(){ int now = 1, cnt = 0; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { a[i][j] = now; ++cnt; if (cnt == p[now]) cnt = 0, now++; } }}inline void sa(){ double t = 1.0, delta; if (n * m &lt;= 400) delta = 0.9999900001; memcpy(tmp, a, sizeof(a)); while (t &gt; 1e-5) { std::pair&lt;int, int&gt; pos1, pos2; pos1.first = rand() % n + 1; pos2.first = rand() % n + 1; pos1.second = rand() % m + 1; pos2.second = rand() % m + 1; while (tmp[pos1.first][pos1.second] == tmp[pos2.first][pos2.second]) { pos1.first = rand() % n + 1; pos2.first = rand() % n + 1; pos1.second = rand() % m + 1; pos2.second = rand() % m + 1; } std::swap(tmp[pos1.first][pos1.second], tmp[pos2.first][pos2.second]); int num = calc(tmp) - calc(a); if (num &lt; 0) std::swap(a[pos1.first][pos1.second], a[pos2.first][pos2.second]); else if (exp(-num / t) * RAND_MAX &gt; rand()) std::swap(a[pos1.first][pos1.second], a[pos2.first][pos2.second]); else std::swap(tmp[pos1.first][pos1.second], tmp[pos2.first][pos2.second]); t *= delta; }}int main(){ srand(107); n = read(), m = read(), c = read(); for (int i = 1; i &lt;= c; i++) p[i] = read(); init(); for (int i = 1; i &lt;= 2; i++) sa(); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) printf(\"%d \", a[i][j]); puts(\"\"); } return 0;}","link":"/2019/02/09/洛谷3936/"},{"title":"洛谷 P3950 部落冲突","text":"link-cut tree 板子题 这道题可以用来作为link-cut tree的练手题 C操作:把发生战争的俩部落的连边cut掉 U操作:把停战的俩部落link起来 Q操作:如果p部落和q部落在一棵树里(树根相同)，就输出”Yes”,否则输出”No” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;const int MaxN = 300010;int n, m, val[MaxN], p[MaxN], q[MaxN], war;struct Link_Cut_Tree{ int top, ch[MaxN][2], fa[MaxN], sum[MaxN], q[MaxN], rev[MaxN]; inline void pushup(int x) { sum[x] = sum[ch[x][0]] ^ sum[ch[x][1]] ^ val[x]; } inline void pushdown(int x) { int l = ch[x][0], r = ch[x][1]; if (rev[x]) { rev[l] ^= 1; rev[r] ^= 1; rev[x] ^= 1; swap(ch[x][0], ch[x][1]); } } inline bool isroot(int x) { return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; } void rotate(int x) { int y = fa[x], z = fa[y], l, r; if (ch[y][0] == x) l = 0; else l = 1; r = l ^ 1; if (!isroot(y)) { if (ch[z][0] == y) ch[z][0] = x; else ch[z][1] = x; } fa[x] = z; fa[y] = x; fa[ch[x][r]] = y; ch[y][l] = ch[x][r], ch[x][r] = y; pushup(y), pushup(x); } void splay(int x) { top = 1; q[top] = x; for (int i = x; !isroot(i); i = fa[i]) q[++top] = fa[i]; for (int i = top; i; i--) pushdown(q[i]); while (!isroot(x)) { int y = fa[x], z = fa[y]; if (!isroot(y)) { if ((ch[y][0] == x) ^ (ch[z][0] == y)) rotate(x); else rotate(y); } rotate(x); } } void access(int x) { for (int t = 0; x; t = x, x = fa[x]) splay(x), ch[x][1] = t, pushup(x); } void makeroot(int x) { access(x); splay(x); rev[x] ^= 1; } int find(int x) { access(x); splay(x); while (ch[x][0]) x = ch[x][0]; return x; } void split(int x, int y) { makeroot(x); access(y); splay(y); } void cut(int x, int y) { makeroot(x); if (find(y) != x || fa[x] != y || ch[x][1]) return; fa[x] = ch[y][0] = 0; pushup(y); } void link(int x, int y) { makeroot(x); fa[x] = y; }} t;int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt; n; i++) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); t.link(u, v); } for(int i = 1; i &lt;= m; i++) { std::string op; std::cin &gt;&gt; op; if(op == \"Q\") { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); int fx = t.find(x), fy = t.find(y); if(fx == fy) printf(\"Yes\\n\"); else printf(\"No\\n\"); } else if(op == \"C\") { ++war; scanf(\"%d%d\", &amp;p[war], &amp;q[war]); t.cut(p[war], q[war]); } else { int x; scanf(\"%d\", &amp;x); t.link(p[x], q[x]); } } return 0;}","link":"/2019/02/07/洛谷3950/"},{"title":"洛谷4211 [LNOI2014]LCA","text":"可以发现题目可以转化为把从$l$到$r$节点到$1$的路径上的点的点权都加上$1$，然后统计$1$到$z$路径上的点权 然后发现这个东西可以差分。。。 于是我们就把询问拆成$l-1$和$r$,然后按$r$排序 从$1$到$n$把$1$到$i$路径点权全部$+1$ 询问时查询$1$到$z$路径点权和 然后就做完了。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181# include &lt;bits/stdc++.h&gt;const int mod = 201314;const int MaxN = 100010;struct edge{ int next, to;};struct node{ int l, r; int sum, tag;};struct query{ int r, z, id;};edge e[MaxN &lt;&lt; 1];query q[MaxN &lt;&lt; 1];int n, m, cnt, dfsnum;int hson[MaxN], fa[MaxN], dfn[MaxN], ans[MaxN];int head[MaxN], size[MaxN], dep[MaxN], top[MaxN];struct SegmentTree{ node t[MaxN &lt;&lt; 2]; inline void pushup(int id){t[id].sum = t[id &lt;&lt; 1].sum + t[id &lt;&lt; 1 | 1].sum;} inline void build(int id, int l, int r) { t[id].l = l, t[id].r = r; if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); } inline void pushdown(int id) { if(t[id].tag) { t[id &lt;&lt; 1].sum += t[id].tag * (t[id &lt;&lt; 1].r - t[id &lt;&lt; 1].l + 1); t[id &lt;&lt; 1 | 1].sum += t[id].tag * (t[id &lt;&lt; 1 | 1].r - t[id &lt;&lt; 1 | 1].l + 1); t[id &lt;&lt; 1].tag += t[id].tag; t[id &lt;&lt; 1 | 1].tag += t[id].tag; t[id].tag = 0; } } inline void modify(int id, int l, int r, int val) { if(t[id].l &gt; r || t[id].r &lt; l) return; if(l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) { t[id].sum += val * (t[id].r - t[id].l + 1); t[id].tag += val; return; } pushdown(id); modify(id &lt;&lt; 1, l, r, val); modify(id &lt;&lt; 1 | 1, l, r, val); pushup(id); } inline int query(int id, int l, int r) { if(t[id].l &gt; r || t[id].r &lt; l) return 0; if(l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) return t[id].sum; pushdown(id); return query(id &lt;&lt; 1, l, r) + query(id &lt;&lt; 1 | 1, l, r); }}T;inline int cmp(query a, query b){ return a.r &lt; b.r;}inline void add_edge(int u, int v){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;}inline void dfs1(int u, int f){ size[u] = 1; for(int i = head[u]; i; i = e[i].next) { int v = e[i].to; if(v == f) continue; dep[v] = dep[u] + 1; fa[v] = u; dfs1(v, u); size[u] += size[v]; if(size[v] &gt; size[hson[u]]) hson[u] = v; }}inline void dfs2(int u, int Top){ ++dfsnum; dfn[u] = dfsnum; top[u] = Top; if(hson[u]) dfs2(hson[u], Top); for(int i = head[u]; i; i = e[i].next) { int v = e[i].to; if(v == fa[u] || v == hson[u]) continue; dfs2(v, v); }}inline void update_chain(int u, int v){ while(top[u] != top[v]) { if(dep[top[u]] &lt; dep[top[v]]) std::swap(u, v); T.modify(1, dfn[top[u]], dfn[u], 1); u = fa[top[u]]; } if(dep[u] &lt; dep[v]) std::swap(u, v); T.modify(1, dfn[v], dfn[u], 1);}inline int query_chain(int u, int v){ int ans = 0; while(top[u] != top[v]) { if(dep[top[u]] &lt; dep[top[v]]) std::swap(u, v); ans += T.query(1, dfn[top[u]], dfn[u]); u = fa[top[u]]; } if(dep[u] &lt; dep[v]) std::swap(u, v); ans += T.query(1, dfn[v], dfn[u]); return ans;}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 2; i &lt;= n; i++) { int u; scanf(\"%d\", &amp;u); ++u; add_edge(i, u); add_edge(u, i); } dep[1] = 1; dfs1(1, 0), dfs2(1, 1); T.build(1, 1, n); for(int i = 1; i &lt;= m; i++) { int l, r, z; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;z); l++, r++, z++; q[i * 2 - 1] = (query){l - 1, z, i * 2 - 1}; q[i * 2] = (query){r, z, i * 2}; } int now = 1; std::sort(q + 1, q + 2 * m + 1, cmp); for(int i = 1; i &lt;= n; i++) { update_chain(1, i); while(q[now].r &lt; i) ++now; while(q[now].r == i) { ans[q[now].id] = query_chain(1, q[now].z); ++now; } } for(int i = 1; i &lt;= m; i++) printf(\"%d\\n\", (ans[i * 2] - ans[i * 2 - 1]) % mod); return 0; }","link":"/2019/03/14/洛谷4211/"},{"title":"洛谷4114 QTree1","text":"很明显这是一道树剖题 但是，树剖是在点上进行的操作，如何把它转化到边上呢？ 不难发现，每一个点与他的父亲节点之间仅有唯一的一条边 于是我们可以把这条边的边权转化为这个儿子节点的点权。 然后还有一点要注意 查询时，我们是不能查询到$(u, v)$的LCA的因为$LCA$的点权是$LCA与$fa[LCA]4之间的边权 而我们并没有统计这鬼东西 怎么办呢？ 注意到当$top[u] = top[v]$时，$v$就是$u$的$LCA$ 所以我们此时查询$(dfn[v+1], dfn[u])$即可 代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;bits/stdc++.h&gt;const int MaxN = 500010;struct edge{ int next, to, dis;};struct node{ int max; int l, r;};edge e[MaxN &lt;&lt; 1];int n, cnt, dfsnum;int a[MaxN], head[MaxN], dep[MaxN], fa[MaxN], size[MaxN];int hson[MaxN], dfn[MaxN], top[MaxN], from[MaxN], to[MaxN], pre[MaxN];struct SegmentTree{ node t[MaxN &lt;&lt; 2]; inline void pushup(int id) { t[id].max = std::max(t[id &lt;&lt; 1].max, t[id &lt;&lt; 1 | 1].max); } inline void build(int id, int l, int r) { t[id].l = l, t[id].r = r; if (l == r) { t[id].max = a[pre[l]]; return; } int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); pushup(id); } inline void modify(int id, int l, int r, int val) { if (t[id].l &gt; r || t[id].r &lt; l) return; if (l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) { t[id].max = val; return; } modify(id &lt;&lt; 1, l, r, val); modify(id &lt;&lt; 1 | 1, l, r, val); pushup(id); } inline int query(int id, int l, int r) { if (l &gt; t[id].r || r &lt; t[id].l) return 0; if (l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) return t[id].max; return std::max(query(id &lt;&lt; 1, l, r), query(id &lt;&lt; 1 | 1, l, r)); }} T;inline void add_edge(int u, int v, int d){ ++cnt; e[cnt].to = v; e[cnt].dis = d; e[cnt].next = head[u]; head[u] = cnt;}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline void dfs1(int u, int f){ size[u] = 1; for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (v == f) continue; fa[v] = u; dep[v] = dep[u] + 1; a[v] = e[i].dis; dfs1(v, u); size[u] += size[v]; if (size[hson[u]] &lt; size[v]) hson[u] = v; }}inline void dfs2(int u, int Top){ ++dfsnum; dfn[u] = dfsnum; pre[dfsnum] = u; top[u] = Top; if (hson[u]) dfs2(hson[u], Top); for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (v == fa[u] || v == hson[u]) continue; dfs2(v, v); }}inline void modify(int pos, int val) { T.modify(1, dfn[pos], dfn[pos], val); }inline int query_chain(int u, int v){ int ans = 0; if (dfn[u] &lt; dfn[v]) std::swap(u, v); while (top[u] != top[v]) { if (dfn[u] &lt; dfn[v]) std::swap(u, v); ans = std::max(ans, T.query(1, dfn[top[u]], dfn[u])); u = fa[top[u]]; } if (dfn[u] &lt; dfn[v]) std::swap(u, v); ans = std::max(ans, T.query(1, dfn[v] + 1, dfn[u])); return ans;}int main(){ n = read(); for (int i = 1; i &lt; n; i++) { int u, v, d; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;d); from[i] = u; to[i] = v; add_edge(u, v, d); add_edge(v, u, d); } dep[1] = 1, fa[1] = 0; dfs1(1, 0), dfs2(1, 1); T.build(1, 1, n); std::string op; std::cin &gt;&gt; op; while (op != \"DONE\") { if (op == \"CHANGE\") { int x = read(), val = read(); int u = from[x], v = to[x]; if (fa[v] == u) std::swap(u, v); modify(u, val); } else { int a = read(), b = read(); printf(\"%d\\n\", query_chain(a, b)); } std::cin &gt;&gt; op; } return 0;}","link":"/2019/03/10/洛谷4114/"},{"title":"洛谷 P4396 [AHOI2013]作业","text":"思路：莫队+分块 这题其实跟Gty的二逼妹子序列非常像 把那题代码改改就行了 首先区间问题，可以离线，马上想到莫队 然后发现不会修改？怎么办？ (好像可以树状数组做，可是我不会o((⊙﹏⊙))o 我们可以把值域分块，这样就可以做到每次查询$O(\\sqrt n)​$，修改$O(1)​$了 总复杂度$O(m \\sqrt n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;#define getpos(x) ((x - 1) / block + 1)#define getblock(x) ((x - 1) * block + 1)const int MaxN = 100010;struct query{ int id, pos; int l, r, a, b;};query q[MaxN];int n, m, size, block;int a[MaxN], cnt[MaxN], sum[MaxN][3], ans[MaxN][3];inline int cmp(query a, query b){ if (a.pos != b.pos) return a.pos &lt; b.pos; return a.r &lt; b.r;}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline void add(int x){ ++cnt[a[x]]; ++sum[getpos(a[x])][1]; if (cnt[a[x]] == 1) ++sum[getpos(a[x])][2];}inline void del(int x){ --cnt[a[x]]; --sum[getpos(a[x])][1]; if (cnt[a[x]] == 0) --sum[getpos(a[x])][2];}inline void ask(int x){ int id = q[x].id, l = q[x].a, r = q[x].b, Posl = getpos(q[x].a), Posr = getpos(q[x].b); for (int i = Posl + 1; i &lt; Posr; i++) ans[id][1] += sum[i][1], ans[id][2] += sum[i][2]; if (Posl == Posr) { for (int i = l; i &lt;= r; i++) { ans[id][1] += cnt[i]; if (cnt[i]) ans[id][2]++; } } else { int L = getblock(Posr), R = getblock(Posl + 1) - 1; for (int i = l; i &lt;= R; i++) { ans[id][1] += cnt[i]; if (cnt[i]) ans[id][2]++; } for (int i = L; i &lt;= r; i++) { ans[id][1] += cnt[i]; if (cnt[i]) ans[id][2]++; } }}inline void solve(){ int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) { while (l &gt; q[i].l) --l, add(l); while (r &lt; q[i].r) ++r, add(r); while (l &lt; q[i].l) del(l), l++; while (r &gt; q[i].r) del(r), r--; ask(i); }}int main(){ n = read(), m = read(); size = pow(n, 0.55), block = sqrt(n); for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= m; i++) { q[i].l = read(), q[i].r = read(); q[i].a = read(), q[i].b = read(); q[i].id = i, q[i].pos = (q[i].l - 1) / size + 1; } std::sort(q + 1, q + m + 1, cmp); solve(); for (int i = 1; i &lt;= m; i++) printf(\"%d %d\\n\", ans[i][1], ans[i][2]); return 0;}","link":"/2019/02/06/洛谷4396/"},{"title":"洛谷4314 cpu监控","text":"首先我们可以想到一个显而易见的思路：每个节点维护$\\mathrm{add,set}$的$tag$,维护最大值$max$和历史最大值$Max$,然后像正常的线段树一样维护 然后你惊讶的发现你只拿到二十分（只有$Q$的部分分） 为什么呢？我们发现有些$tag$，他还没有来得及被更新就被覆盖了..而这些$tag$本来能改变世界更新答案 所以我们可以维护两个$tag$:$\\mathrm{Add,Set}$表示该节点从上次下放到目前的最大$add$和$set$值 然后我们就可以快乐的用这些$tag$来维护答案了 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define sum(a, b, mod) ((a + b) % mod)#define checkmax(a, b) ((a) = ((a) &lt; (b)) ? (b) : (a))const int MaxN = 1e5 + 10;const int inf = 0x3f3f3f3f;struct node{ int l, r; int Max, Add, Set; int max, add, set;};int n, m, a[MaxN];struct SegmentTree{ node t[MaxN &lt;&lt; 2]; inline void pushup(int id) { t[id].max = std::max(t[id &lt;&lt; 1].max, t[id &lt;&lt; 1 | 1].max); t[id].Max = std::max(t[id &lt;&lt; 1].Max, t[id &lt;&lt; 1 | 1].Max); } inline void build(int id, int l, int r) { t[id].l = l, t[id].r = r, t[id].set = t[id].Set = -inf; if (l == r) { t[id].max = t[id].Max = a[(l + r) &gt;&gt; 1]; return; } int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); pushup(id); } inline void checksum(int id, int add, int Add) { if (t[id].set != -inf) { checkmax(t[id].Set, t[id].set + Add); checkmax(t[id].Max, t[id].max + Add); t[id].set += add, t[id].max += add; } else { checkmax(t[id].Add, t[id].add + Add); checkmax(t[id].Max, t[id].max + Add); t[id].add += add, t[id].max += add; } } inline void checkset(int id, int set, int Set) { checkmax(t[id].Set, Set); checkmax(t[id].Max, Set); t[id].set = set, t[id].max = set; } inline void pushdown(int id) { checksum(id &lt;&lt; 1, t[id].add, t[id].Add), checksum(id &lt;&lt; 1 | 1, t[id].add, t[id].Add), t[id].add = t[id].Add = 0; if (t[id].set != -inf) { checkset(id &lt;&lt; 1, t[id].set, t[id].Set), checkset(id &lt;&lt; 1 | 1, t[id].set, t[id].Set); t[id].set = t[id].Set = -inf; } } void add(int id, int l, int r, int val) { if (t[id].l &gt; r || t[id].r &lt; l) return; if (l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) { checksum(id, val, val); return; } pushdown(id), add(id &lt;&lt; 1, l, r, val), add(id &lt;&lt; 1 | 1, l, r, val), pushup(id); } void set(int id, int l, int r, int val) { if (t[id].l &gt; r || t[id].r &lt; l) return; if (l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) { checkset(id, val, val); return; } pushdown(id), set(id &lt;&lt; 1, l, r, val), set(id &lt;&lt; 1 | 1, l, r, val), pushup(id); } int query_max(int id, int l, int r) { if (t[id].l &gt; r || t[id].r &lt; l) return -inf; if (l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) return t[id].max; pushdown(id); return std::max(query_max(id &lt;&lt; 1, l, r), query_max(id &lt;&lt; 1 | 1, l, r)); } int query_Max(int id, int l, int r) { if (t[id].l &gt; r || t[id].r &lt; l) return -inf; if (l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) return t[id].Max; pushdown(id); return std::max(query_Max(id &lt;&lt; 1, l, r), query_Max(id &lt;&lt; 1 | 1, l, r)); }} T;char get(){ char ch = getchar(); while (ch &gt; 'Z' || ch &lt; 'A') ch = getchar(); return ch;}inline int read(){ int x = 0, f = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') { if (ch == '-') f = 0; ch = getchar(); } while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return f ? x : (-x);}int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]); T.build(1, 1, n); scanf(\"%d\", &amp;m); while (m--) { char ch = get(); int x = read(), y = read(), z; if (ch == 'Q') printf(\"%d\\n\", T.query_max(1, x, y)); else if (ch == 'A') printf(\"%d\\n\", T.query_Max(1, x, y)); else if (ch == 'P') z = read(), T.add(1, x, y, z); else z = read(), T.set(1, x, y, z); } return 0;}","link":"/2019/10/07/洛谷4314/"},{"title":"洛谷 P4867 【Gty的二逼妹子序列】","text":"莫队好题 这种题一看直接莫队啊 但是我们要想想怎么修改 一开始我想树状数组，但是我不会写o((⊙﹏⊙))o 后来看了一下Solution，发现可以将值域分块，这样就可以做到查询$O(\\sqrt n)$，修改$O(1)$了 总复杂度$O(m \\sqrt n)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;#define getindex(x) ((x - 1) * block + 1)#define getpos(x) ((x - 1) / block + 1)const int MaxN = 1e5 + 10, MaxM = 1e6 + 10;struct query{ int id, pos; int l, r, a, b;};query q[MaxM];int n, m, size, block;int a[MaxN], ans[MaxM], cnt[MaxN], sum[MaxN];inline int cmp(query a, query b){ if (a.pos != b.pos) return a.pos &lt; b.pos; return a.r &lt; b.r;}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline void ins(int x){ ++cnt[a[x]]; if (cnt[a[x]] == 1) ++sum[getpos(a[x])];}inline void del(int x){ --cnt[a[x]]; if (cnt[a[x]] == 0) --sum[getpos(a[x])];}inline int ask(int a, int b, int l, int r){ int ans = 0, Posl = getpos(l), Posr = getpos(r); for (int i = Posl + 1; i &lt; Posr; i++) ans += sum[i]; if (Posl == Posr) { for (int i = l; i &lt;= r; i++) if (cnt[i]) ++ans; } else { int L = getindex(Posr), R = getindex(Posl + 1) - 1; for (int i = l; i &lt;= R; i++) if (cnt[i]) ++ans; for (int i = L; i &lt;= r; i++) if (cnt[i]) ++ans; } return ans;}inline void solve(){ int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) { while (l &gt; q[i].l) l--, ins(l); while (r &lt; q[i].r) r++, ins(r); while (l &lt; q[i].l) del(l), l++; while (r &gt; q[i].r) del(r), r--; ans[q[i].id] = ask(q[i].l, q[i].r, q[i].a, q[i].b); }}int main(){ n = read(), m = read(); size = pow(n, 0.55), block = sqrt(n); for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= m; ++i) { q[i].l = read(), q[i].r = read(); q[i].a = read(), q[i].b = read(); q[i].id = i, q[i].pos = (q[i].l - 1) / size + 1; } std::sort(q + 1, q + m + 1, cmp); solve(); for (int i = 1; i &lt;= m; i++) printf(\"%d\\n\", ans[i]); return 0;}","link":"/2019/02/06/洛谷4867/"},{"title":"洛谷4284 [SHOI2014]概率充电器","text":"设$f_u$表示$u$不被以$u$为根的子树内点(包括$u$)通上电的概率，则有: $$f_u=(1-p_u) \\times \\prod_{v \\in subtree \\; u}e(u, v) \\times f_v$$ 为什么是这个式子呢？ 我们发现，一个节点$u$不被通电当且仅当$u$不自己通电（废话）且$u$的子树内所有节点不能导电给$u$ 这个式子还有问题:他处理不了给$u$导电的点在$u$子树外的情况 因此我们可以采取一个换根的思路 设$g_u$表示$u$不通电的概率，则$g_u$可以通过$u$的子树和剩余部分计算，子树部分我们已经处理过，而剩余部分可以通过$u$的父亲计算，设$h_u$表示非$u$子树里的点导电给$u$的概率，我们有: $$h_u = \\frac{g_{fa}}{1 - e(fa, u) + e(fa, u) \\times f_u}$$ 通过$h$计算$g$ $$g_u=f_u \\times (1-e(fa, u) + e(fa, u) * h_u)$$ 原理与$f$相似 于是$ans=\\sum_{i=1}^n (1-g_i)$ 代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define sum(a, b, mod) ((a + b) % mod)const int MaxN = 5e5 + 10;struct edge{ double d; int next, to;};edge e[MaxN &lt;&lt; 1];int n, cnt;int head[MaxN];double p[MaxN], f[MaxN], g[MaxN], h[u];inline void add_edge(int u, int v, double d){ ++cnt; e[cnt].to = v; e[cnt].d = d; e[cnt].next = head[u]; head[u] = cnt;}inline void dfs(int u, int fa){ f[u] = 1 - p[u]; for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (v == fa) continue; dfs(v, u), f[u] *= (1 - e[i].d + (e[i].d * f[v])); }}inline void dfs1(int u, int fa, int id){ if (u == 1) g[u] = f[u]; else { h[u] = g[fa] / (1 - e[id].d + e[id].d * f[u]); g[u] = f[u] * (1 - e[id].d + e[id].d * h[u]); } for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (v == fa) continue; dfs1(v, u, i); }}int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; i++) { int u, v; double d; scanf(\"%d%d%lf\", &amp;u, &amp;v, &amp;d), d *= 0.01; add_edge(u, v, d), add_edge(v, u, d); } for (int i = 1; i &lt;= n; i++) scanf(\"%lf\", &amp;p[i]), p[i] *= 0.01; dfs(1, 0), dfs1(1, 0, 0); double ans = 0; for (int i = 1; i &lt;= n; i++) ans += 1.00 - g[i]; printf(\"%.6lf\", ans); return 0;}","link":"/2019/10/17/洛谷4284/"},{"title":"洛谷4768 [NOI2018] 归程","text":"题目大意有一个$n$个点$m$条边的无向联通图， 每条边有两个属性：长度$d$，海拔$h$ 有$q$个询问，每个询问给定两个数$v$, $p$，你要找到一个节点$u$，其中$u$要满足$v$到$u$存在一条路径使得这条路径上的边海拔全部大于$p$，求所有可能的$u$到$1$的最短路长度的最小值 分析显然，我们发现$v$到$u$的路径一定在$u$到$v$的最大生成树上。（例：货车运输） 把边按照海拔降序排列，建出该图的$\\texttt{kruskal}$重构树，则对于一个节点$s$， 若$s$的点权$val \\leq p$则该子树里的所有节点都互相连通（即能开车抵达）。 我们通过$\\texttt{dijkstra}$预处理出每个点到$1$的最短路$dis_i$， 并在建出$\\texttt{kruskal}$重构树之后在重构树上$\\texttt{dfs}$求出每个节点的子树里$dis$的最小值$mind_i$。询问时只要找到$v$最大的点权$\\leq p$的祖先$x$，则$mind_x$就是本题的答案。 $x$的寻找可以使用树上倍增算法，（在满足条件的情况下）逐级往上跳 时间复杂度$O(m \\log m)$ 一些额外的东西这里补充讲一下$\\texttt{kruskal}$重构树是怎么建出来的： 1.像正常的$\\texttt{kruskal}$重构树那样把所有边按照边权降序/升序排序 2.在合并一条边的两个端点$u, \\; v$时，我们不像原来那样把$v$联通块的根节点$fv$设为$fu$，而是新建一个节点$new$并把$new$设为$fu, \\; fv$的父亲，并在图中连上$(new, \\; fu)$和$(new, \\; fv)$两条边，此时该新点的点权就是$u$, $v$最大/小生成树路径上最小/大值 3.重复步骤$2$直到所有边都被遍历一遍 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define sum(a, b, mod) (((a) + (b)) % mod)const int MaxN = 8e5 + 10;const int MaxM = 1e6 + 10;struct edge{ int next, to, dis;};struct Edge{ int u, v, ht;};struct node{ int pos, dis; bool operator&lt;(node x) const { return dis &gt; x.dis; }};edge e[MaxM];Edge t[MaxN];int n, m, q, k, s, cnt, num;int head[MaxM], dep[MaxM], f[MaxM], val[MaxM], mind[MaxN];int u[MaxN], v[MaxN], l[MaxN], a[MaxN], dis[MaxN], vis[MaxN], fa[MaxN][21];int cmp(Edge a, Edge b) { return a.ht &gt; b.ht; }void link(int u, int v, int a) { ++cnt, t[cnt].u = u, t[cnt].v = v, t[cnt].ht = a; }int getf(int x){ if (x != f[x]) f[x] = getf(f[x]); return f[x];}void rebuild(){ cnt = 0; for (int i = 1; i &lt;= m; i++) link(u[i], v[i], a[i]);}int jump(int u, int k){ for (int i = 20; ~i; i--) if (val[fa[u][i]] &gt; k) u = fa[u][i]; return u;}void add_edge(int u, int v, int d){ ++cnt; e[cnt].to = v; e[cnt].dis = d; e[cnt].next = head[u]; head[u] = cnt;}void init(){ n = m = cnt = num = 0; memset(f, 0, sizeof(fa)); memset(fa, 0, sizeof(fa)); memset(dep, 0, sizeof(dep)); memset(vis, 0, sizeof(vis)); memset(val, 0, sizeof(val)); memset(head, 0, sizeof(head)); memset(mind, 0x3f, sizeof(mind));}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}void dfs(int u, int fa){ dep[u] = dep[fa] + 1, ::fa[u][0] = fa; for (int i = 1; i &lt;= 20; i++) ::fa[u][i] = ::fa[::fa[u][i - 1]][i - 1]; for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (v == fa) continue; dfs(v, u), mind[u] = std::min(mind[u], mind[v]); }}void kruskal(){ num = n, cnt = 0; memset(head, 0, sizeof(head)); std::sort(t + 1, t + m + 1, cmp); for (int i = 1; i &lt;= n; i++) f[i] = i; for (int i = 1; i &lt;= m; i++) { int fu = getf(t[i].u), fv = getf(t[i].v); if (fu != fv) { val[++num] = t[i].ht; f[num] = f[fu] = f[fv] = num; add_edge(fu, num, 0), add_edge(num, fu, 0); add_edge(fv, num, 0), add_edge(num, fv, 0); } } dfs(num, 0);}void dijkstra(int u){ std::priority_queue&lt;node&gt; q; memset(dis, 0x3f, sizeof(dis)); dis[u] = 0, q.push((node){u, 0}); while (!q.empty()) { node x = q.top(); q.pop(), u = x.pos; if (vis[u]) continue; vis[u] = 1; for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (dis[u] + e[i].dis &lt; dis[v]) { dis[v] = dis[u] + e[i].dis; if (!vis[v]) q.push((node){v, dis[v]}); } } } for (int i = 1; i &lt;= n; i++) mind[i] = dis[i];}int main(){ int T = read(); while (T--) { int lastans = 0; init(), n = read(), m = read(); for (int i = 1; i &lt;= m; i++) { u[i] = read(), v[i] = read(), l[i] = read(), a[i] = read(); add_edge(u[i], v[i], l[i]), add_edge(v[i], u[i], l[i]); } dijkstra(1), rebuild(), kruskal(); q = read(), k = read(), s = read(); while (q--) { int v = (read() + k * lastans - 1) % n + 1, p = (read() + k * lastans) % (s + 1); lastans = mind[jump(v, p)], printf(\"%d\\n\", lastans); } } return 0;}","link":"/2020/02/26/洛谷4768/"},{"title":"洛谷 P5018 【对称二叉树】","text":"本题考察选手对DFS及树结构的掌握程度 首先，你把数据读入之后，先用一个大法师把以每个节点为根的子树的大小和权值都预处理出来，方便待会剪枝 然后，你对以每个节点为根的子树，都判断一下以下条件（这时刚才处理的东西就有用了） ① 左子树和右子树的节点数是否相等 ② 左子树和右子树的权值是否相等 ③ 以当前节点为根的子树大小是不是超过答案 第三个很重要，不加（洛谷 数据）最后一个点会TLE 有一个显而易见的剪枝：因为答案至少是1，所以大小为1的子树就不用check了，不然浪费常数 然后就是暴力判了 递归下去，建立两个队列，保存当前处理到的左子树上和右子树上的节点，判左子树当前节点的左儿子和右子树当前节点的右儿子权值是否相等，右子树当前节点的左儿子和左子树当前节点的右儿子权值是否相等（注意对应） 还有判下对应的节点有没有一个是空的一个没空的情况 如果不相等就返回 相等的话就扔进队列（注意对应顺序！） 注意：上述处理一定要左右子树一起做，不能先处理一边，再处理另一边，不然会WA 到最后如果都可以的话就return true 附考场代码 不得不说，为了能过，我加了一堆卡常 3e6的输入规模应该还是要快读的吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117# include &lt;bits/stdc++.h&gt;# define R register const int MaxN = 1000010;struct node//节点{ int val; int l, r;};node a[MaxN];int f[MaxN], val[MaxN], ind[MaxN];//f[i]表示以i为根的子树大小，val表示以i为根的子树权值和，ind没啥用inline void read(int &amp;x)//快读{ x = 0; bool op = 1; char ch = getchar(); while(ch &gt; '9' || ch &lt; '0') { if(ch == '-') op = 0; ch = getchar(); } while(ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch - '0'), ch = getchar(); if(!op) x = -x;}void dfs(int root){ if(root == -1) return; if(a[root].l == -1 &amp;&amp; a[root].r == -1) f[root] = 1, val[root] = a[root].val; else { dfs(a[root].l); dfs(a[root].r); f[root] = f[a[root].l] + f[a[root].r] + 1; val[root] = val[a[root].l] + val[a[root].r] + a[root].val; }}inline int check(int x){ std::queue&lt;int&gt; l, r; l.push(x), r.push(x); while(!l.empty() || !r.empty()) { if(l.empty() || r.empty()) return false;//一边空了，一边没空 R int lx = l.front(), rx = r.front(); l.pop(), r.pop(); if(a[lx].val != a[rx].val) return false; R int lson[3], rson[3]; lson[1] = a[lx].l, lson[2] = a[lx].r;//左子树当前节点的左儿子,左子树当前节点的右儿子 rson[1] = a[rx].l, rson[2] = a[rx].r;//右子树当前节点的左儿子,右子树当前节点的右儿子 if((lson[1] == -1 &amp;&amp; rson[2] != -1) || (lson[1] != -1 &amp;&amp; rson[2] == -1)) return false;//一边空了，一边没空 if((lson[2] == -1 &amp;&amp; rson[1] != -1) || (lson[2] != -1 &amp;&amp; rson[1] == -1)) return false;//一边空了，一边没空 if(lson[1] != -1) l.push(lson[1]); if(lson[2] != -1) l.push(lson[2]); if(rson[2] != -1) r.push(rson[2]); if(rson[1] != -1) r.push(rson[1]); //推进队列 } return true;}int main(){// freopen(\"tree.in\", \"r\", stdin);// freopen(\"tree.out\", \"w\", stdout); R int n; scanf(\"%d\", &amp;n); for(R unsigned i = 1; i &lt;= n; ++i) read(a[i].val); for(R unsigned i = 1; i &lt;= n; ++i) read(a[i].l), read(a[i].r), ++ind[a[i].l], ++ind[a[i].r];//处理入度 R unsigned root; for(R unsigned i = 1; i &lt;= n; ++i) { if(!ind[i]) { root = i; break; } }//找树根 dfs(root);//预处理 int ans = 1; for(R unsigned i = 1; i &lt;= n; ++i)//枚举子树 { if(f[a[i].l] != f[a[i].r]) continue;//剪枝1 if(val[a[i].l] != val[a[i].r]) continue;//剪枝2 if(f[i] &lt; ans || f[i] == 1) continue;//剪枝3 if(check(i)) ans = f[i];//更新答案 } printf(\"%d\", ans); fclose(stdin); fclose(stdout); return 0;}","link":"/2019/02/06/洛谷5018/"},{"title":"FJWC2020 小记","text":"这里记录$\\texttt{little_sun}$的$\\texttt{FJWC2020}$之旅 Day 11 Life1.1 简要题意一个$n$个点的有向图，每个点有颜色，部分点的颜色已经确定定义一条任意相邻点不同色的路径为交错路径为所有颜色未定的点确定颜色，并为所有$1 \\leq i &lt; j \\leq n$，确定图上从$i$到$j$的有向边是否存在求有多少种方案使得该图交错路径的条数为奇数，对大质数取模$1\\leq n \\leq 2 \\times 10^5$ 1.2 分析我们设$g_i$表示以$i$结尾的交错路径条数，这样我们有了这样一个$\\texttt{dp}$思路： 设$f[i][j][k][h]$表示前$i$个点，有$j$个黑点，有$k$个白点满足他的$g$为奇数，且这$i$个点的$g$之和的奇偶性为$h$的方案数 我们发现如果$i+1$是黑点的话那么只有那$k$个白点会对$g_{i+1}$的奇偶性产生影响，故只要考虑这些点的子集与$i+1$的连边的方案数就好了，白色同理 又因为这些点在计算中都相当于等价的，于是我们只要考虑这些点的子集大小的奇偶性即可 设$calc(x, y)$表示一个大小为$x$的集合取大小奇偶性为$y$的集合的方案数，则我们有了如下一个$\\texttt{dp}$方程组:1.$f[i+1][j][k][h]+=f[i][j][k][h] \\times calc(k, 1) \\times 2^{i-k} $ 2.$f[i+1][j+1][k][h \\oplus 1]+=f[i][j][k][h] \\times calc(k, 0) \\times 2^{i-k}$ 3.$f[i+1][j][k][h]+=f[i][j][k][h] \\times calc(j, 1) \\times 2^{i-j}$ 4.$f[i+1][j][k+1][h \\oplus 1]+=f[i][j][k][h] \\times calc(j, 0) \\times 2^{i-j} $ 要注意的是，若$i+1$被钦定为黑色则$3,4$转移不可取，白色同理，复杂度$O(n^3)$ 我们发现: $calc(k, 0)\\times2^{i-k}=(k \\; ? \\; 2^{i-1} : 2^i)$$calc(k, 1)\\times2^{i-k}=(k \\; ? \\; 2^{i-1} : 0)$ 于是我们就可以不记$j, k$的值了，改记满足条件的黑白点的存在性，方程变成$f[i][0/1][0/1][0/1]$， 最后的$ans=\\sum_{j,k \\in {0,1}} f[n][j][k][1]$ 1.3 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define sum(a, b, mod) (((a) + (b)) % mod)const int MaxN = 5e5 + 10;const int mod = 998244353;int f[MaxN][2][2][2];int n, m, col[MaxN], pow2[MaxN];inline int read(){ int x = 0, f = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') { if (ch == '-') f = 0; ch = getchar(); } while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return f ? x : (-x);}int main(){ n = read(), pow2[0] = 1; for (int i = 1; i &lt;= n; i++) col[i] = read(), pow2[i] = (pow2[i - 1] * 2ll) % mod; f[0][0][0][0] = 1; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt;= 1; j++) { for (int k = 0; k &lt;= 1; k++) { for (int h = 0; h &lt;= 1; h++) { if (col[i + 1] != 1) { f[i + 1][j][k][h] = sum(f[i + 1][j][k][h], f[i][j][k][h] * 1ll * (k ? pow2[i - 1] : 0), mod); f[i + 1][j | 1][k][h ^ 1] = sum(f[i + 1][j | 1][k][h ^ 1], f[i][j][k][h] * 1ll * (k ? pow2[i - 1] : pow2[i]), mod); } if (col[i + 1] != 0) { f[i + 1][j][k][h] = sum(f[i + 1][j][k][h], f[i][j][k][h] * 1ll * (j ? pow2[i - 1] : 0), mod); f[i + 1][j][k | 1][h ^ 1] = sum(f[i + 1][j][k | 1][h ^ 1], f[i][j][k][h] * 1ll * (j ? pow2[i - 1] : pow2[i]), mod); } } } } } int ans = 0; for (int j = 0; j &lt;= 1; j++) for (int k = 0; k &lt;= 1; k++) ans = sum(ans, f[n][j][k][1], mod); printf(\"%d\\n\", ans); return 0;} 2 Winner2.1 简要题意给定一个$n$个点$m$条边的无向图 求给所有边定向使得$1$和$2$可以到达同一个点的方案数 $1 \\leq n \\leq 15, 1 \\leq n \\leq \\frac{n \\times (n - 1)}{2}$ 2.2 分析发现正着做很难搞，考虑用总数减去不合法的数目 设$1$能到达的点集为$S$, $2$能到达的点集为$T$，则不合法的方案数就是$S \\cap T = \\emptyset$的方案数 设$f_S$表示对点集$S$的导出子图中的边定向能使得$1$能到达$S$内所有节点的方案数$(1 \\in S)$，$g_T$表示$2$的类似东西 那么枚举$S,T$如果没有边横跨$S,T$，则这两个点集内部的定向方案数为$f_S \\times g_T$ 而在$S,T$之外，如果有一条边横跨$S \\cup T$内外，则这条边只能从$S \\cup T$内连到$S \\cup T$外，否则这条边可以随便连，于是现在就可以算出答案了，由于$S \\cap T = \\emptyset$，所以时间复杂度$O(3 ^ n)$ 现在我们考虑怎么计算$f,g$，同样考虑用总数减去不合法的数目，对于集合$S$，总数显然是$2^{S的导出子图边数}$ 枚举$S$的真子集$T$，考虑只能到$T$的方案数，则点集$T$内部的方案数显然为$f_T$，外部的方案数为$2^{S-T的导出子图边数}$, 对于横跨$T$与$S-T$的边，显然只能从$S-T$连到$T$，于是这时扣掉的方案数为$f_T*2^{S-T的导出子图边数}$，由于枚举子集，时间复杂度$O(3^n)$ 2.3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define sum(a, b, mod) (((a) + (b)) % mod)const int MaxN = 16;const int mod = 1e9 + 7;int n, m, id;int pow2[MaxN * MaxN], gr[MaxN][MaxN], c[1 &lt;&lt; MaxN], d[1 &lt;&lt; MaxN], f[3][1 &lt;&lt; MaxN];inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}int main(){ n = read(), m = read(), id = read(), pow2[0] = 1; for (int i = 1; i &lt;= m; i++) { int x = read(), y = read(); ++gr[x][y], pow2[i] = (pow2[i - 1] * 2ll) % mod; } int lim = (1 &lt;&lt; n); for (int s = 0; s &lt; lim; s++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (gr[i][j]) { if ((s &amp; (1 &lt;&lt; (i - 1))) &amp;&amp; (s &amp; (1 &lt;&lt; (j - 1)))) c[s] += gr[i][j]; if ((s &amp; (1 &lt;&lt; (i - 1))) || (s &amp; (1 &lt;&lt; (j - 1)))) d[s] += gr[i][j]; } for (int id = 1; id &lt;= 2; id++) { for (int s = 0; s &lt; lim; s++) { if (!(s &amp; (1 &lt;&lt; (id - 1)))) continue; f[id][s] = pow2[c[s]]; for (int t = (s - 1) &amp; s; t; t = (t - 1) &amp; s) f[id][s] = sum(f[id][s], (-f[id][t] * 1ll * pow2[c[s - t]]) % mod + mod, mod); } } int ans = pow2[m]; for (int s = 0; s &lt; lim; s++) { if ((!(s &amp; 1)) || (s &amp; 2)) continue; for (int t = lim - 1 ^ s; t; t = ((t - 1) &amp; (lim - 1 ^ s))) { // printf(\"%d %d %d\\n\", s, t, ans); if ((!(t &amp; 2)) || c[s] + c[t] &lt; c[s | t]) continue; ans = sum(ans, ((-1ll * f[1][s] * f[2][t]) % mod) * pow2[m - d[s + t]] % mod + mod, mod); } } printf(\"%d\\n\", ans); return 0;} 3 Brr咕咕咕 Day 21 Building咕咕咕 2 Bracelet咕咕咕 3 Number3.1 简要题意给定操作数$n$和一个数$k$，实现一个集合$s$，支持插入和删除操作。 每次操作后输出$s$内满足$gcd(s_i, s_j) = k$的$(i,j)$对数 令$z$为集合内出现过的数的最大值，则有$1 \\leq n,z \\leq 10^5$ 3.2 分析题目可以转化为每次加入/删除一个数，并求这个数和集合内多少数的$\\texttt{gcd}=k$ 容易发现如果一个数不能被$k$整除，那么这个数一定对答案没有贡献 所以问题又转化为每次加入/删除一个数，并求这个数和集合内多少数的$\\texttt{gcd}=1$ 考虑容斥，那么发现当加入一个数$x$的时候，答案会增加:$$\\sum_{d|x}cnt[d] \\times mu[d]$$其中$cnt[i]$表示$i$的倍数出现过多少次，时间复杂度$O(n \\sqrt z)$ 3.3 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;#define R register#define ll long long#define sum(a, b, mod) (((a) + (b)) % mod)const ll MaxN = 5e5 + 10;ll n, k, cnt, ans;ll prime[MaxN], p[MaxN], mu[MaxN], val[MaxN], vis[MaxN];inline ll read(){ ll x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}void add(ll x, ll v){ for (ll i = 1; i * i &lt;= x; i++) { if (x % i == 0) { val[i] += v; if (i * i != x) val[x / i] += v; } }}ll query(ll x){ ll ret = 0; for (ll i = 1; i * i &lt;= x; i++) { if (x % i == 0) { ret += mu[i] * val[i]; if (i * i != x) ret += mu[x / i] * val[x / i]; } } return ret;}inline void prework(){ ll n = 200000; mu[1] = 1, p[0] = p[1] = 1; for (ll i = 2; i &lt;= n; i++) { if (!p[i]) prime[++cnt] = i, mu[i] = -1; for (ll j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++) { p[i * prime[j]] = 1; if (i % prime[j] == 0) break; mu[i * prime[j]] = -mu[i]; } }}int main(){ freopen(\"number.in\", \"r\", stdin); freopen(\"number.out\", \"w\", stdout); prework(); n = read(), k = read(); while (n--) { ll op = read(), x = read(); if (op == 1) { if (x % k == 0) vis[x / k]++, ans += query(x / k), add(x / k, 1); } else { if (x % k == 0 &amp;&amp; vis[x / k]) vis[x / k]--, add(x / k, -1), ans -= query(x / k); } printf(\"%lld\\n\", ans); } return 0;} Day 3咕咕咕 Day 41 Hakugai1.1 简要题意有一个数列$g_i$满足$g_0=a,g_1=b,g_i=3*g_{i-1}-g_{i-2} \\ (i \\geq 2)$ ，其中$a,b$是给定的常数 现在我们有一个数列$f_{n,k}$满足$f_{n,0}=n,f_{n,k}=f_{g_n,k-1}$，给定$a,b,n,k,p$，求$f_{n,k}$对$p$取模的结果 $1 \\leq n, p \\leq 10^9, 0 \\le a,b \\le p, 0 \\le k \\leq 100$ 1.2 分析由于$k\\le100$，所以我们考虑暴力求循环节，然后用矩阵快速幂暴力计算 我们发现题目中的数列是个二阶常系数递推，写出前几项发现是个斐波那契数列 于是斐波那契数列的循环节就很好求了 设要求斐波那契数列对$p$取模的循环节$f(p)$， 若$p=p_1^{k_1} \\times \\cdots \\times p_m^{k_m}$，（其中$p_i$为$p$的第$i$个质因子） 则有$f(p)= lcm(f(p_i) \\times p_i^{k_i-1})$，又当$p_i$是质数的时候，若$p_i \\equiv \\pm1$，则$f(p_i)=p_i-1$，否则$f(p_i)=2\\times(p_i+1)$ 现在我们会求循环节了，考虑怎么求题目要求的东西 容易发现我们要求的是$g_{g_{g_{\\cdots g_{n}}}}$（嵌套$k$层），那么我们发现： 1.第$1$层求的是$ g_i \\; mod \\; p$的循环节，循环节为$f(p)$ 2.第$2$层求的是$ g_i \\; mod \\; f(p)$的循环节，循环节为$f(f(p))$ 以此类推，故我们只要把该过程迭代$k$遍就好了 1.3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187# include &lt;bits/stdc++.h&gt;# define ll long long# define R registerconst ll MaxN = 1e6 + 10;struct matrix{ ll n, m; ll a[5][5]; matrix(ll x = 0, ll y = 0) { n = x, m = y; memset(a, 0, sizeof(a)); }};ll a, b, n, k, mod, cnt, faccnt;ll prime[MaxN], p[MaxN], fac[1000][20];ll gcd(ll a, ll b){return b ? gcd(b, a % b) : a;}ll lcm(ll a, ll b){return a / gcd(a, b) * b;}ll mul(ll x, ll y, ll p){return x * y - (ll) ((long double) x * y / p) * p;}ll fast_pow(ll a, ll b, ll mod){ ll ret = 1; while(b) { if(b &amp; 1) ret = mul(ret, a, mod) % mod; a = mul(a, a, mod) % mod; b &gt;&gt;= 1; } return ret;}matrix mul(matrix a, matrix b, ll mod){ matrix c(a.n, b.m); for(int i = 1; i &lt;= a.n; i++) for(int j = 1; j &lt;= b.m; j++) for(int k = 1; k &lt;= a.m; k++) c.a[i][j] = (c.a[i][j] + mul(a.a[i][k], b.a[k][j], mod) % mod + mod) % mod; return c;}matrix I(){ matrix c(2, 2); c.a[1][1] = 1; c.a[2][2] = 1; return c;}matrix pow(matrix a, ll b, ll mod){ matrix ret = I(); while(b) { if(b &amp; 1) ret = mul(ret, a, mod); a = mul(a, a, mod); b &gt;&gt;= 1; } return ret;}matrix init1(){ matrix a(2, 2); a.a[1][1] = 3, a.a[1][2] = -1; a.a[2][1] = 1, a.a[2][2] = 0; return a;}matrix init2(){ matrix c(2, 1); c.a[1][1] = b; c.a[2][1] = a; return c;}ll getf(ll x, ll mod){ if(x == 0) return a % mod; if(x == 1) return b % mod; matrix a = init1(), b = init2(), res = mul(pow(a, x-1, mod), b, mod); return (res.a[1][1] % mod + mod) % mod;}void prework(){ ll n = 1000000; p[0] = p[1] = 1; for(int i = 2; i &lt;= n; i++) { if(!p[i]) prime[++cnt] = i; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++) { p[i * prime[j]] = 1; if(i % prime[j] == 0) break; } }}void getfac(ll x){ ll tmp = x; for(int i = 1; i &lt;= faccnt + 1; i++) fac[i][0] = fac[i][1] = 0;faccnt = 0; for(int i = 1; prime[i] &lt;= tmp / prime[i]; i++) { if(tmp % prime[i] == 0) { ++faccnt; fac[faccnt][0] = prime[i]; while((tmp % prime[i]) == 0 &amp;&amp; tmp != 1) fac[faccnt][1]++, tmp /= prime[i]; } } if(tmp != 1) { ++faccnt; fac[faccnt][0] = tmp; fac[faccnt][1] = 1; }}ll g(ll p){ ll num; (p % 5 == 1 || p % 5 == 4) ? (num = p - 1) : (num = 2 * (p + 1)); return num;}std::map&lt;ll, ll&gt; m;ll getloop(ll n){ if(m.find(n) != m.end()) return m[n]; getfac(n); ll ans = 1; for(int i = 1; i &lt;= faccnt; i++) { ll res = 1; if(fac[i][0] == 2) res = 3; else if(fac[i][0] == 3) res = 8; else if(fac[i][0] == 5) res = 20; else res = g(fac[i][0]); for(int j = 1; j &lt; fac[i][1]; j++) res *= fac[i][0]; ans = lcm(ans, res); } return m[n] = ans;} int main(){ freopen(\"hakugai.in\", \"r\", stdin); freopen(\"hakugai.out\", \"w\", stdout); ll T; prework(); scanf(\"%lld\", &amp;T); while(T--) { scanf(\"%lld%lld%lld%lld%lld\", &amp;a, &amp;b, &amp;n, &amp;k, &amp;mod); if(k == 1) { printf(\"%lld\\n\", getf(n, mod)); continue; } ll loop[101] = {mod}; for(int i = 1; i &lt;= k; i++) loop[i] = getloop(loop[i - 1]); n %= loop[k]; for(int i = k - 1; ~i; i--) n = getf(n, loop[i]); ll ans = n; printf(\"%lld\\n\", ans); } return 0;}","link":"/2020/01/18/FJWC2020/"},{"title":"洛谷3178 [HAOI2015] 树上操作","text":"就是个树剖的模板题嘛。。。。 两边dfs把树割成链, 然后在链上线段树维护 做完了。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include &lt;bits/stdc++.h&gt;#define int long longconst int MaxN = 100010;struct edge{ int next, to;};struct node{ int l, r; int sum, tag;};edge e[MaxN &lt;&lt; 1];int n, m, cnt, dfscnt;int a[MaxN], head[MaxN], dfn[MaxN], pre[MaxN];int top[MaxN], dep[MaxN], hson[MaxN], fa[MaxN], size[MaxN];struct SegmentTree{ node t[MaxN &lt;&lt; 2]; inline void pushup(int id) { t[id].sum = t[id &lt;&lt; 1].sum + t[id &lt;&lt; 1 | 1].sum; } void build(int id, int l, int r) { t[id].l = l, t[id].r = r; if (l == r) { t[id].sum = a[pre[l]]; return; } int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); pushup(id); } inline void pushdown(int id) { if (t[id].tag) { t[id &lt;&lt; 1].sum += t[id].tag * (t[id &lt;&lt; 1].r - t[id &lt;&lt; 1].l + 1); t[id &lt;&lt; 1 | 1].sum += t[id].tag * (t[id &lt;&lt; 1 | 1].r - t[id &lt;&lt; 1 | 1].l + 1); t[id &lt;&lt; 1].tag += t[id].tag, t[id &lt;&lt; 1 | 1].tag += t[id].tag; t[id].tag = 0; } } void modify(int id, int l, int r, int delta) { if (l &gt; t[id].r || r &lt; t[id].l) return; if (l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) { t[id].sum += delta * (t[id].r - t[id].l + 1); t[id].tag += delta; return; } if (t[id].l == t[id].r) return; pushdown(id); modify(id &lt;&lt; 1, l, r, delta); modify(id &lt;&lt; 1 | 1, l, r, delta); pushup(id); } int query(int id, int l, int r) { if (l &gt; t[id].r || r &lt; t[id].l) return 0; if (l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) return t[id].sum; if (t[id].l == t[id].r) return 0; pushdown(id); return query(id &lt;&lt; 1, l, r) + query(id &lt;&lt; 1 | 1, l, r); }} T;inline void add_edge(int u, int v){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;}void dfs1(int u, int f){ size[u] = 1; for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (v == f) continue; dep[v] = dep[u] + 1, fa[v] = u; dfs1(v, u); size[u] += size[v]; if (size[v] &gt; size[hson[u]]) hson[u] = v; }}void dfs2(int u, int Top){ ++dfscnt; dfn[u] = dfscnt; pre[dfscnt] = u; top[u] = Top; if (hson[u]) dfs2(hson[u], Top); for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (v == fa[u] || v == hson[u]) continue; dfs2(v, v); }}inline int read(){ int x = 0, f = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') { if (ch == '-') f = 0; ch = getchar(); } while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return f ? x : (-x);}inline int query(int u, int v){ int ans = 0; while (top[u] != top[v]) { if (dep[u] &lt; dep[v]) std::swap(u, v); ans += T.query(1, dfn[top[u]], dfn[u]); u = fa[top[u]]; } if (dep[u] &lt; dep[v]) std::swap(u, v); ans += T.query(1, dfn[v], dfn[u]); return ans;}signed main(){ n = read(), m = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt; n; i++) { int u = read(), v = read(); add_edge(u, v); add_edge(v, u); } dep[1] = 1, fa[1] = 0; dfs1(1, 0), dfs2(1, 1); T.build(1, 1, n); for (int i = 1; i &lt;= m; i++) { int op = read(); if (op == 1) { int u = read(), x = read(); T.modify(1, dfn[u], dfn[u], x); } if (op == 2) { int u = read(), x = read(); T.modify(1, dfn[u], dfn[u] + size[u] - 1, x); } if (op == 3) { int u = read(); printf(\"%lld\\n\", query(u, 1)); } } return 0;}","link":"/2019/02/22/洛谷3178/"},{"title":"「洛谷2146」软件包管理器","text":"zcy会写树剖啦！ 本题为树链剖分的模板题 对于”install x”操作, 将$x$到根节点路径上所有点的点权全部赋值为$1$ 对于”uninstall x”操作, 将$x$及$x$的子树点权全部赋值为$0$​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;using namespace std;const int MaxN = 150010;struct edge{ int to, next;};struct node{ int l, r; int sum, tag;};struct SegmentTree{ node t[MaxN &lt;&lt; 1]; inline void pushup(int id) { t[id].sum = t[id &lt;&lt; 1].sum + t[id &lt;&lt; 1 | 1].sum; } void build(int id, int l, int r) { t[id].l = l, t[id].r = r, t[id].tag = -1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); } inline void pushdown(int id) { if (t[id].tag != -1) { t[id &lt;&lt; 1].sum = t[id].tag * (t[id &lt;&lt; 1].r - t[id &lt;&lt; 1].l + 1); t[id &lt;&lt; 1 | 1].sum = t[id].tag * (t[id &lt;&lt; 1 | 1].r - t[id &lt;&lt; 1 | 1].l + 1); t[id &lt;&lt; 1].tag = t[id].tag; t[id &lt;&lt; 1 | 1].tag = t[id].tag; t[id].tag = -1; } } inline void modify(int id, int l, int r, int delta) { if (l &gt; t[id].r || t[id].l &gt; r) return; if (l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) { t[id].sum = delta * (t[id].r - t[id].l + 1); t[id].tag = delta; return; } if (t[id].l == t[id].r) return; pushdown(id); modify(id &lt;&lt; 1, l, r, delta); modify(id &lt;&lt; 1 | 1, l, r, delta); pushup(id); return; } inline int query(int id, int l, int r) { if (l &gt; t[id].r || t[id].l &gt; r) return 0; if (l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) return t[id].sum; if (t[id].l == t[id].r) return 0; pushdown(id); return query(id &lt;&lt; 1, l, r) + query(id &lt;&lt; 1 | 1, l, r); }} T;edge e[MaxN &lt;&lt; 1];int n, m, cnt, dfsnum, size[MaxN], hson[MaxN];int head[MaxN], top[MaxN], dfn[MaxN], fa[MaxN], dep[MaxN];inline void add_edge(int u, int v){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;}inline void dfs1(int u, int f){ size[u] = 1; for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (v == f) continue; dep[v] = dep[u] + 1; fa[v] = u; dfs1(v, u); size[u] += size[v]; if (size[v] &gt; size[hson[u]]) hson[u] = v; }}inline void dfs2(int u, int Top){ ++dfsnum; dfn[u] = dfsnum; top[u] = Top; if (hson[u]) dfs2(hson[u], Top); for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (v == hson[u] || v == fa[u]) continue; dfs2(v, v); }}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline void update_tree(int u){ T.modify(1, dfn[u], dfn[u] + size[u] - 1, 0);}inline void update_chain(int u, int v, int delta){ while (top[u] != top[v]) { if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); T.modify(1, dfn[top[u]], dfn[u], delta); u = fa[top[u]]; } if (dep[u] &lt; dep[v]) swap(u, v); T.modify(1, dfn[v], dfn[u], delta);}signed main(){ n = read(); for (int i = 2; i &lt;= n; ++i) { int u = read() + 1; add_edge(i, u); add_edge(u, i); } dep[1] = 1, fa[1] = 0; dfs1(1, 0), dfs2(1, 1); T.build(1, 1, n); m = read(); for (int i = 1; i &lt;= m; i++) { string op; cin &gt;&gt; op; int before = T.t[1].sum; if (op == \"install\") { int u = read() + 1; update_chain(u, 1, 1); int after = T.t[1].sum; printf(\"%d\\n\", after - before); } else { int u = read() + 1; update_tree(u); int after = T.t[1].sum; printf(\"%d\\n\", before - after); } } return 0;}","link":"/2019/02/21/洛谷2146/"}],"tags":[{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"构造","slug":"构造","link":"/tags/构造/"},{"name":"集训队作业","slug":"集训队作业","link":"/tags/集训队作业/"},{"name":"其他","slug":"其他","link":"/tags/其他/"},{"name":"dijkstra","slug":"dijkstra","link":"/tags/dijkstra/"},{"name":"图论","slug":"图论","link":"/tags/图论/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"数学","slug":"数学","link":"/tags/数学/"},{"name":"莫队","slug":"莫队","link":"/tags/莫队/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"搜索","slug":"搜索","link":"/tags/搜索/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"差分","slug":"差分","link":"/tags/差分/"},{"name":"前缀和","slug":"前缀和","link":"/tags/前缀和/"},{"name":"01trie","slug":"01trie","link":"/tags/01trie/"},{"name":"数列","slug":"数列","link":"/tags/数列/"},{"name":"矩阵加速","slug":"矩阵加速","link":"/tags/矩阵加速/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","link":"/tags/矩阵快速幂/"},{"name":"单调栈","slug":"单调栈","link":"/tags/单调栈/"},{"name":"贪心","slug":"贪心","link":"/tags/贪心/"},{"name":"DFS序","slug":"DFS序","link":"/tags/DFS序/"},{"name":"二分","slug":"二分","link":"/tags/二分/"},{"name":"字符串","slug":"字符串","link":"/tags/字符串/"},{"name":"hash","slug":"hash","link":"/tags/hash/"},{"name":"SA","slug":"SA","link":"/tags/SA/"},{"name":"SAM","slug":"SAM","link":"/tags/SAM/"},{"name":"树","slug":"树","link":"/tags/树/"},{"name":"网络流","slug":"网络流","link":"/tags/网络流/"},{"name":"网络流24题","slug":"网络流24题","link":"/tags/网络流24题/"},{"name":"费用流","slug":"费用流","link":"/tags/费用流/"},{"name":"模拟退火","slug":"模拟退火","link":"/tags/模拟退火/"},{"name":"随机化","slug":"随机化","link":"/tags/随机化/"},{"name":"模板","slug":"模板","link":"/tags/模板/"},{"name":"树套树","slug":"树套树","link":"/tags/树套树/"},{"name":"ST表","slug":"ST表","link":"/tags/ST表/"},{"name":"堆","slug":"堆","link":"/tags/堆/"},{"name":"NOI","slug":"NOI","link":"/tags/NOI/"},{"name":"斜率优化","slug":"斜率优化","link":"/tags/斜率优化/"},{"name":"状压dp","slug":"状压dp","link":"/tags/状压dp/"},{"name":"link-cut tree","slug":"link-cut-tree","link":"/tags/link-cut-tree/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/树链剖分/"},{"name":"分块","slug":"分块","link":"/tags/分块/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"概率期望","slug":"概率期望","link":"/tags/概率期望/"},{"name":"树形dp","slug":"树形dp","link":"/tags/树形dp/"},{"name":"倍增","slug":"倍增","link":"/tags/倍增/"},{"name":"kruskal重构树","slug":"kruskal重构树","link":"/tags/kruskal重构树/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"}],"categories":[{"name":"Solution","slug":"Solution","link":"/categories/Solution/"},{"name":"Contest","slug":"Contest","link":"/categories/Contest/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Template","slug":"Template","link":"/categories/Template/"}]}