{"pages":[{"title":"About","text":"About me一个初二学生，OIer，菜的一匹","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"Todo","text":"这里记录zcy已经/准备学的一些(tg+)算法 Done: 莫队 树链剖分 Todo: 离线分治算法","link":"/plan/index.html"},{"title":"friends","text":"本校同学little_sun: little_sun 外省大佬Siyuan: Siyuan’s Blog yzhang: yzhang’s Blog","link":"/friends/index.html"}],"posts":[{"title":"「算法笔记」 莫队","text":"前言莫队，可是传说中能够解决所有离线区间问题的神奇算法 引子我们先来看这样一道题： 有一个包含了$n$个数的序列$a_i$ 有$m$次询问，每次询问$[l,r]$区间中有多少个不同的数 $n,m \\leq 5*10^4$ 你会怎么做？暴力？ 暴力复杂度是$O(nm)$的，会$T$ 12345678910111213for(int i = 1; i &lt;= m; i++){ int ans = 0; memset(cnt, 0, sizeof(cnt)); for(int j = l[i]; j &lt;= r[i]; j++) { ++cnt[a[i]]; if(cnt[a[i]] == 1) ++ans; } printf(\"%d\\n\", ans);}// 暴力-未优化版 我们来观察一下暴力： 暴力每次询问$[l_i,r_i]$时上一次询问的$[l_{i-1},r_{i-1}]$所存储下来的信息就都被抛弃了 如果我们把上一次查询存储下来的信息再利用呢？ 123456789101112131415//前面询问没有排序int l = 1, r = 0, sum = 0;for (int i = 1; i &lt;= m; i++){ while (l &gt; q[i].l) l--, cnt[a[l]]++, sum += ((cnt[a[l]] == 1) ? 1 : 0); while (r &lt; q[i].r) r++, cnt[a[r]]++, sum += ((cnt[a[r]] == 1) ? 1 : 0); while (l &lt; q[i].l) cnt[a[l]]--, sum -= ((cnt[a[l]] == 0) ? 1 : 0), l++; while (r &gt; q[i].r) cnt[a[r]]--, sum -= ((cnt[a[r]] == 0) ? 1 : 0), r--; printf(\"%d\\n\", sum);}// 暴力-优化*1 很不幸，这样写还是会$T$.出题人可以构造数据使你相邻两次查询没有相交项，然后这就成了一个比暴力还劣的算法 但是我们已经离真正的莫队很近了 我们可以把询问分块，把询问依照左端点分成$O(\\sqrt n)$块,块内再按右端点排序。 这样子算法的总复杂度就是$O(n \\sqrt n)$的 但是，这个复杂度要怎么证明呢？ 莫队的复杂度分析块内转移 左端点 在同一个块里面，由于左端点都在一个长度为$O(\\sqrt n)$的区间里面所以在同一块里面移动一次，左端点最多变化$O(\\sqrt n)$总共有$m$个询问，那么同一个块里面的左端点变化最多是$O(m\\sqrt n)$的 右端点 由于每个块里面的询问都按右端点排序所以右端点在一个块里面最多变化$n$有 $\\sqrt n$个块，那么右端点移动最多就是$O(n\\sqrt n)$ 跨块转移容易发现这样的转移总共会发生$\\sqrt n$次 左端点 单次跨块转移的复杂度为$O(\\sqrt n)$,总复杂度为$O(\\sqrt n * \\sqrt n)=O(n)$ 右端点 由于跨块时，右端点是无序的，所以在最坏情况下右端点单次转移的复杂度为$O(n)$,总复杂度为$O(n * \\sqrt n)=O(n \\sqrt n)$ 综上所述，莫队算法的复杂度是$O(n\\sqrt n)$(由于$m$与$n$在同一个数量级，所以统一一下就成了$O(n\\sqrt n)$了，毕竟这是渐进时间复杂度) 范例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#define ll long longconst int MaxN = 500010;struct query{ int l, r, id, pos; bool operator&lt;(const query &amp;x) const { if (pos == x.pos) return r &lt; x.r; else return pos &lt; x.pos; }};query q[MaxN];int a[MaxN], n, m, k;int cnt[MaxN &lt;&lt; 1], ans[MaxN];inline int read(){ int x = 0; char ch = getchar(); while(ch &gt; '9' || ch &lt; '0') ch = getchar(); while(ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}int main(){ n = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); m = read(); int size = (int)pow(n, 0.55); //莫队的块大小不一定要根号n,可以视题目而定 for (int i = 1; i &lt;= m; i++) { q[i].l = read(), q[i].r = read(); q[i].id = i, q[i].pos = (q[i].l - 1) / size + 1; } std::sort(q + 1, q + m + 1); int l = 1, r = 0, sum = 0; for (int i = 1; i &lt;= m; i++) { while (l &gt; q[i].l) l--, cnt[a[l]]++, sum += ((cnt[a[l]] == 1) ? 1 : 0); while (r &lt; q[i].r) r++, cnt[a[r]]++, sum += ((cnt[a[r]] == 1) ? 1 : 0); while (l &lt; q[i].l) cnt[a[l]]--, sum -= ((cnt[a[l]] == 0) ? 1 : 0), l++; while (r &gt; q[i].r) cnt[a[r]]--, sum -= ((cnt[a[r]] == 0) ? 1 : 0), r--; ans[q[i].id] = sum; } for (int i = 1; i &lt;= m; i++) printf(\"%d\\n\", ans[i]); return 0;} 习题 P2709 小B的询问 普通莫队模板题，建议初学者从这道题入手 P1972 [SDOI2009]HH的项链 普通莫队模板题，建议初学者从这道题入手 P3901 数列找不同 可以转化成莫队来做 P1494 [国家集训队]小Z的袜子 普通莫队模板题 P4137 Rmq Problem / mex 普通莫队模板题，修改有一些思维难度 CF375D Tree and Queries 树上问题转区间问题，可以用莫队解决 SP3267 DQUERY - D-query HH的项链数据弱化版 P4396 [AHOI2013]作业 莫队套分块 P4867 Gty的二逼妹子序列 莫队套分块，是上题第二小问的数据加强版 P3709 大爷的字符串题 区间众数模板题，不要求在线 带修莫队留坑待填 树上莫队留坑待填","link":"/2019/02/10/Algorithm-莫队/"},{"title":"「算法笔记」Dijkstra","text":"前言 $SPFA​$算法由于它上限 $O(NM) = O(VE)​$的时间复杂度,被卡掉的几率很大.在算法竞赛中,我们需要一个更稳定的算法:$dijkstra​$. 什么是$dijkstra$? $dijkstra​$是一种单源最短路径算法,时间复杂度上限为$O(n^2)​$(朴素),在实际应用中较为稳定$;​$加上堆优化之后更是具有$O((n+m)\\log_{2}n)​$的时间复杂度,在稠密图中有不俗的表现. $dijkstra$的原理/流程? $dijkstra$本质上的思想是贪心,它只适用于不含负权边的图. 我们把点分成两类,一类是已经确定最短路径的点,称为”白点”,另一类是未确定最短路径的点,称为”蓝点” $dijkstra$的流程如下$:$ $1.$ 初始化$dis[start] = 0,$其余节点的$dis$值为无穷大. $2.$ 找一个$dis$值最小的蓝点$x,$把节点$x$变成白点. $3.$ 遍历$x$的所有出边$(x,y,z),$若$dis[y] &gt; dis[x] + z,$则令$dis[y] = dis[x] + z$ $4.$ 重复$2,3$两步,直到所有点都成为白点$.$ 时间复杂度为$O(n^2)$ $dijkstra$为什么是正确的 当所有边长都是非负数的时候,全局最小值不可能再被其他节点更新.所以在第$2$步中找出的蓝点$x$必然满足$:dis[x]$已经是起点到$x$的最短路径$.$我们不断选择全局最小值进行标记和拓展,最终可以得到起点到每个节点的最短路径的长度 图解 (令$start = 1$) 开始时我们把$dis[start]$初始化为$0$,其余点初始化为$inf$ 第一轮循环找到$dis$值最小的点$1$,将$1$变成白点,对所有与$1$相连的蓝点的$dis$值进行修改,使得$dis[2]=2,dis[3]=4,dis[4]=7$ 第二轮循环找到$dis$值最小的点$2$,将$2$变成白点,对所有与$2$相连的蓝点的$dis$值进行修改,使得$dis[3]=3,dis[5]=4$ 第三轮循环找到$dis$值最小的点$3$,将$3$变成白点,对所有与$2$相连的蓝点的$dis$值进行修改,使得$dis[4]=4$ 接下来两轮循环分别将$4,5$设为白点,算法结束,求出所有点的最短路径 时间复杂度$O(n^2)$ 为什么$dijkstra$不能处理有负权边的情况? 我们来看下面这张图 $2$到$3$的边权为$-4$,显然从$1$到$3$的最短路径为$-2$ $(1-&gt;2-&gt;3).$但在循环开始时程序会找到当前$dis$值最小的点$3$,并标记它为白点. 这时的$dis[3]=1,$然而$1$并不是起点到$3$的最短路径.因为$3$已经被标为白点,所以$dis[3]$不会再被修改了.我们在边权存在负数的情况下得到了错误的答案. $dijkstra$的堆优化? 观察$dijkstra$的流程,发现步骤$2$可以优化 怎么优化呢? 我会zkw线段树!我会斐波那契堆! 我会堆! 我们可以用堆对$dis$数组进行维护,用$O(\\log_{2}n)$的时间取出堆顶元素并删除,用$O(\\log_{2}n)$遍历每条边,总复杂度$O((n+m)\\log_{2}n)$ 范例代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;const int MaxN = 100010, MaxM = 500010;struct edge{ int to, dis, next;};edge e[MaxM];int head[MaxN], dis[MaxN], cnt;bool vis[MaxN];int n, m, s;inline void add_edge( int u, int v, int d ){ cnt++; e[cnt].dis = d; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;}struct node{ int dis; int pos; bool operator &lt;( const node &amp;x )const { return x.dis &lt; dis; }};std::priority_queue&lt;node&gt; q;inline void dijkstra(){ dis[s] = 0; q.push( ( node ){0, s} ); while( !q.empty() ) { node tmp = q.top(); q.pop(); int x = tmp.pos, d = tmp.dis; if( vis[x] ) continue; vis[x] = 1; for( int i = head[x]; i; i = e[i].next ) { int y = e[i].to; if( dis[y] &gt; dis[x] + e[i].dis ) { dis[y] = dis[x] + e[i].dis; if( !vis[y] ) { q.push( ( node ){dis[y], y} ); } } } }}int main(){ scanf( \"%d%d%d\", &amp;n, &amp;m, &amp;s ); for(int i = 1; i &lt;= n; ++i)dis[i] = 0x7fffffff; for( register int i = 0; i &lt; m; ++i ) { register int u, v, d; scanf( \"%d%d%d\", &amp;u, &amp;v, &amp;d ); add_edge( u, v, d ); } dijkstra(); for( int i = 1; i &lt;= n; i++ ) printf( \"%d \", dis[i] ); return 0;} 例题 入门模板:P3371 进阶模板:P4779 其余例题请右转洛谷 题库,搜索”最短路” 后记 本文部分内容摘自李煜东《算法竞赛进阶指南》和《信息学竞赛一本通》 友情提示:正权图请使用$dijkstra$算法,负权图请使用$SPFA$算法 感谢洛谷 各位管理员提供的平台","link":"/2019/02/06/Algorithm-Dijkstra/"},{"title":"CF1063B 【Labyrinth】","text":"一道锻炼代码能力的好题 只要bfs一下，向四个方向搜索，剪下枝，就A了（好像还跑的蛮快？） Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define check(x, y) (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m)//判断是否越界const int MaxN = 2010;const int dx[] = {0, 1, -1, 0}, dy[] = {-1, 0, 0, 1};//bfs方向数组struct p{ int x, y; int cntx, cnty;};int ans;int n, m, x, y, limx, limy;std::string s[MaxN];int vis[MaxN][MaxN];int disx[MaxN][MaxN], disy[MaxN][MaxN];void bfs(int x, int y){ memset(disx, 0x3f, sizeof(disx)); memset(disy, 0x3f, sizeof(disy) ); std::queue&lt;p&gt; q; q.push((p){x, y, 0, 0}); disx[x][y] = disy[x][y] = 0; while (!q.empty()) { p tmp = q.front(); q.pop(); x = tmp.x, y = tmp.y; for (int i = 0; i &lt;= 3; i++) { int nx = x + dx[i], ny = y + dy[i]; if (!check(nx, ny) || s[nx][ny] == '*')//当前位置是否合法 continue; int cntx = tmp.cntx + bool(dy[i] == -1), cnty = tmp.cnty + bool(dy[i] == 1);//计算向左/右走步数 if (cntx &lt; std::min(disx[nx][ny], limx + 1) || cnty &lt; std::min(disy[nx][ny], limy + 1))//判断，剪枝 { disx[nx][ny] = cntx; disy[nx][ny] = cnty;//更新向左/右走步数 q.push((p){nx, ny, cntx, cnty}); } } }}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); scanf(\"%d%d\", &amp;x, &amp;y), --x, --y; scanf(\"%d%d\", &amp;limx, &amp;limy); for (int i = 0; i &lt; n; i++) std::cin &gt;&gt; s[i]; bfs(x, y); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (disx[i][j] &lt;= limx &amp;&amp; disy[i][j] &lt;= limy) ++ans;//统计答案 printf(\"%d\\n\", ans); return 0;}","link":"/2019/02/06/CF1063B/"},{"title":"「20190219」赛后总结","text":"总的来说这场比赛打完感触还是蛮深的. 深切体会到了背模板的意义 $T1$ $s$到$t$的路径上所有点显然一定会走到，以$s$为根时$t$子树中的点显然走不到，而其它点都有$\\frac{1}{2}$的概率会走到。 时间复杂度$O(n log_2{n} + m)​$ $T2$ n较小时，我们可以直接用线性筛/埃氏筛法求出每个数的最小质因数。 考虑进行容斥。对于每个质数$x$，我们需要求出$1$~$n/x$中不被比$x$小的质数整除的数的个数。一种简单的思路是，对于$x \\leq k$的情况，我们进行常见的枚举子集容斥；对于$x&gt;k$的情况，$n/x$较小，我们就在$n/k$的范围内进行线性筛/埃氏筛法。 注意到进行子集容斥时，枚举子集后贡献形如$(-1)^i·\\frac{n}{S}$，而$\\frac{n}{S}$只有$O(\\sqrt n )$种取值，可以对这个进行记忆化。 复杂度$\\frac{n^{\\frac{3}{4}}}{\\sqrt{log_2 n}}$ $T3$ 点分治统计树上的情况，然后单独考虑经过剩下那条边的答案。 在环上按顺序枚举一个端点，用树状数组维护另一个端点到这条边的距离。 时间复杂度$O(nlog_2n)$ 总的来说，T1T3的思路基本都有，但是因为代码能力有限，写的题太少，没写出来。。。","link":"/2019/02/19/20190219/"},{"title":"CF375D 【Tree and Queries】","text":"子树上的查询问题可以通过$DFS$序转换为序列问题 我们用$sum_i$表示出现次数$\\geq i$的个数 用$val_i$表示第$i$种颜色的出现次数 那么每次修改时只要$O(1)$修改$sum$和$val​$即可 详见代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;const int MaxN = 100010;struct node{ int val, dfn, r, id;};struct query{ int l, r; int pos, id, k;};struct edge{ int next, to;};node a[MaxN];query q[MaxN];edge e[MaxN &lt;&lt; 1];int n, m, cnt, dfscnt, size;int head[MaxN], ans[MaxN], sum[MaxN], val[MaxN];inline int comp(node a, node b) { return a.dfn &lt; b.dfn; }inline int cmp(query a, query b){ if (a.pos != b.pos) return a.pos &lt; b.pos; return a.r &lt; b.r;}inline void add_edge(int u, int v){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;}inline void dfs(int u){ a[u].dfn = ++dfscnt; for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (!a[v].dfn) dfs(v); } a[u].r = dfscnt;}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline void add(int x) { ++val[a[x].val], ++sum[val[a[x].val]]; }inline void del(int x) { --sum[val[a[x].val]], --val[a[x].val]; }inline void solve(){ int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) { while (l &gt; q[i].l) --l, add(l); while (r &lt; q[i].r) ++r, add(r); while (l &lt; q[i].l) del(l), ++l; while (r &gt; q[i].r) del(r), --r; ans[q[i].id] = sum[q[i].k]; }}int main(){ n = read(), m = read(); size = pow(n, 0.55); for (int i = 1; i &lt;= n; i++) a[i].val = read(), a[i].id = i; for (int i = 1; i &lt;= n - 1; i++) { int u = read(), v = read(); add_edge(u, v); add_edge(v, u); } dfs(1); for (int i = 1; i &lt;= m; i++) { int v, k; v = read(), k = read(); q[i].l = a[v].dfn, q[i].r = a[v].r, q[i].k = k; q[i].id = i, q[i].pos = (q[i].l - 1) / size + 1; } std::sort(q, q + m + 1, cmp); std::sort(a + 1, a + n + 1, comp); solve(); for (int i = 1; i &lt;= m; i++) printf(\"%d\\n\", ans[i]); return 0;}","link":"/2019/02/06/CF375D/"},{"title":"CF550A 【Two Substrings】","text":"思路：暴力判每一个”BA”出现的位置，二分查找他前/后有没有满足条件的”AB”,时间复杂度$O(n\\log_{2}n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# include &lt;bits/stdc++.h&gt;const int MaxN = 100010;std::vector&lt;int&gt; a, b;//存下标int upper(int x)//二分后面的位置{ int l = 0, r = a.size(); while(l &lt; r) { int mid = (l + r) &gt;&gt; 1; if(a[mid] &gt; x) r = mid; else l = mid + 1; } return l;}int lower(int x)//二分前面的位置{ int l = -1, r = a.size() - 1; while(l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; if(a[mid] &lt; x) l = mid; else r = mid - 1; } return l;}int main(){ std::string s; std::cin &gt;&gt; s; int len = s.length(); for(int i = 0; i &lt; len - 1; i++) { std::string tmp = s.substr(i, 2); if(tmp == \"AB\") a.push_back(i); else if(tmp == \"BA\") b.push_back(i); }//查找\"AB\"和\"BA\"出现的位置 if(a.size() == 0 || b.size() == 0) return 0 * printf(\"NO\");//特判 for(int i = 0; i &lt; b.size(); i++) { int x = lower(b[i] - 1);//防重 int y = upper(b[i] + 1); if(x != -1 || y != a.size()) return 0 * printf(\"YES\"); } printf(\"NO\"); return 0;}","link":"/2019/02/06/CF550A/"},{"title":"CF900D 【Unusual Sequences】","text":"数论好题 可以发现如果$x$不整除$y$那么肯定无解 不然我们可以发现其实求的就是和为$y/x$且$gcd(a_1,a_2,\\cdots,a_n)=1$的序列个数 容易发现所有和为$y$的序列个数为$2^{n-1}$ 而所有$gcd$不为$1$的序列，把每个数除以$gcd$,就又回到原题了 所以枚举每个可能的$gcd$(约数)，递归计算即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define ll long longconst ll mod = 1e9 + 7;std::map&lt;int, int&gt; m;std::vector&lt;int&gt; v, vec;int fast_pow(ll a, ll n){ int ret = 1; while (n) { if (n &amp; 1) ret = (1ll * ret * a) % mod; a = (1ll * a * a) % mod; n &gt;&gt;= 1; } return ret;}int solve(int x){ if (m[x]) return m[x]; if (x == 1) { m[x] = 1; return x; } int sum = 0; int s = sqrt(x); for (int i = 1; i &lt;= s; i++) { if (x % i == 0) { if (i == 1 || i * i == x) sum = (sum + solve(i)) % mod; else sum = (sum + solve(i) % mod + solve(x / i) % mod) % mod; } } sum = (fast_pow(2, x - 1) - sum + mod) % mod; m[x] = sum; return sum;}int main(){ ll x, y; std::cin &gt;&gt; x &gt;&gt; y; if (y % x != 0) return 0 * printf(\"0\"); y /= x; std::cout &lt;&lt; solve(y); return 0;}","link":"/2019/02/06/CF900D/"},{"title":"「LOJ 145」DFS序 2","text":"经典的DFS序入门题 题目都告诉你是什么算法了 和「LOJ 144」DFS序 1一样，只不过这次把单点查询的树状数组改成区间修改的线段树罢了 敲下模板就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;bits/stdc++.h&gt;#define ll long longconst int MaxN = 1000010;struct edge{ int to, next;};struct vertex{ int dfn, next, val;};struct node{ int l, r; ll sum, tag;};struct SegmentTree{ ll x[MaxN]; node t[MaxN &lt;&lt; 2]; void pushup(int id) { t[id].sum = t[id &lt;&lt; 1].sum + t[id &lt;&lt; 1 | 1].sum; } inline void build(int id, int l, int r) { t[id].l = l, t[id].r = r; if (l == r) { t[id].sum = x[l]; return; } int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); pushup(id); } inline void pushdown(int id) { if (t[id].tag) { t[id &lt;&lt; 1].tag += t[id].tag; t[id &lt;&lt; 1 | 1].tag += t[id].tag; t[id &lt;&lt; 1].sum += t[id].tag * 1ll * (t[id &lt;&lt; 1].r - t[id &lt;&lt; 1].l + 1); t[id &lt;&lt; 1 | 1].sum += t[id].tag * 1ll * (t[id &lt;&lt; 1 | 1].r - t[id &lt;&lt; 1 | 1].l + 1); t[id].tag = 0; } } inline void modify(int id, int l, int r, int val) { if (l &gt; t[id].r || r &lt; t[id].l) return; if (l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) { t[id].sum += val * 1ll * (t[id].r - t[id].l + 1); t[id].tag += val; return; } if (t[id].l == t[id].r) return; pushdown(id); modify(id &lt;&lt; 1, l, r, val); modify(id &lt;&lt; 1 | 1, l, r, val); pushup(id); } inline ll query(int id, int l, int r) { if (l &gt; t[id].r || r &lt; t[id].l) return 0; if (l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) return t[id].sum; if (t[id].l == t[id].r) return 0; pushdown(id); return query(id &lt;&lt; 1, l, r) + query(id &lt;&lt; 1 | 1, l, r); }} T;edge e[MaxN];vertex a[MaxN];int head[MaxN], vis[MaxN];int n, m, r, cnt, dfscnt;inline void add_edge(int u, int v){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;}inline int read(){ int x = 0, f = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') { if (ch == '-') f = 0; ch = getchar(); } while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return f ? x : (-x);}inline void dfs(int u){ a[u].dfn = vis[u] = ++dfscnt; for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (vis[v]) continue; dfs(v); } a[u].next = dfscnt;}int main(){ n = read(), m = read(), r = read(); for (int i = 1; i &lt;= n; ++i) a[i].val = read(); for (int i = 1; i &lt; n; i++) { int u = read(), v = read(); add_edge(u, v); add_edge(v, u); } dfs(r); for(int i = 1; i &lt;= n; i++) T.x[a[i].dfn] = a[i].val; T.build(1, 1, n); for (int i = 1; i &lt;= m; i++) { int op = read(); if (op == 1) { int pos = read(), x = read(); T.modify(1, a[pos].dfn, a[pos].next, x); } else { int pos = read(); printf(\"%lld\\n\", T.query(1, a[pos].dfn, a[pos].next)); } } return 0;}","link":"/2019/02/19/LOJ-145/"},{"title":"「LOJ 144」 DFS序1","text":"一道经典的DFS序入门题. 很显然对整个子树的修改可以通过DFS序转化为序列问题 于是只要把树转化为序列，再在序列上跑树状数组就好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;#define int long long#define lowbit(x) (x &amp; (-x))const int MaxN = 1e6 + 10;struct edge{ int next, to;};struct node{ int dfn, val, r;};node a[MaxN];edge e[MaxN &lt;&lt; 1];int n, m, r, dfsnum, cnt;int head[MaxN], vis[MaxN], c[MaxN];inline int read(){ int x = 0, f = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') { if (ch == '-') f = 0; ch = getchar(); } while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch - '0'), ch = getchar(); return f ? x : (-x);}inline void add_edge(int u, int v){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;}inline void dfs(int u){ vis[u] = true, a[u].dfn = ++dfsnum; for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (!vis[v]) dfs(v); } a[u].r = dfsnum;}inline void modify(int pos, int x){ while (pos &lt;= n) { c[pos] += x; pos += lowbit(pos); }}inline int query(int pos){ int ans = 0; while (pos) { ans += c[pos]; pos -= lowbit(pos); } return ans;}signed main(){ n = read(), m = read(), r = read(); for (int i = 1; i &lt;= n; i++) a[i].val = read(); for (int i = 1; i &lt; n; i++) { int u = read(), v = read(); add_edge(u, v); add_edge(v, u); } dfs(r); for (int i = 1; i &lt;= n; i++) modify(a[i].dfn, a[i].val); for (int i = 1; i &lt;= m; i++) { int op = read(); if (op == 1) { int pos = read(), x = read(); modify(a[pos].dfn, x); } else { int pos = read(); printf(\"%lld\\n\", query(a[pos].r) - query(a[pos].dfn - 1)); } } return 0;}","link":"/2019/02/11/LOJ-144/"},{"title":"CF86D Powerful array","text":"怎么2700的题这么简单啊QAQ 长得非常像P2709 小B的询问，做法也一样 莫队离线乱搞做完了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define int long longconst int MaxN = 1000010;struct query{ int l, r, id, pos;};query q[MaxN];int n, t, size;int ans[MaxN], sum;int a[MaxN], cnt[MaxN];inline int cmp(query a, query b){ if (a.pos != b.pos) return a.pos &lt; b.pos; return a.r &lt; b.r;}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline void add(int x){ sum += a[x] * (2 * cnt[a[x]] + 1); cnt[a[x]]++;}inline void del(int x){ sum -= a[x] * (2 * cnt[a[x]] - 1); cnt[a[x]]--;}inline void solve(){ int l = 1, r = 0; for (int i = 1; i &lt;= t; i++) { while (l &gt; q[i].l) --l, add(l); while (r &lt; q[i].r) ++r, add(r); while (l &lt; q[i].l) del(l), ++l; while (r &gt; q[i].r) del(r), --r; ans[q[i].id] = sum; }}signed main(){ n = read(), t = read(); size = pow(n, 0.55); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt;= t; i++) { q[i].l = read(), q[i].r = read(); q[i].id = i, q[i].pos = (q[i].l - 1) / size + 1; } std::sort(q + 1, q + t + 1, cmp); solve(); for (int i = 1; i &lt;= t; i++) printf(\"%lld\\n\", ans[i]); return 0;}","link":"/2019/02/28/CF86D/"},{"title":"洛谷 P1337 [JSOI2004]平衡点 / 吊打XXX","text":"一些模拟退火的注意事项： 开始温度要设到比较高 在不超时的情况下多随几次 最好确定一个随机种子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;const int MaxN = 1010;const double delta = 0.993;struct node{ int x, y, w;};int n;node a[MaxN];double ansx, ansy;double ans = 1e18, t;inline int read(){ bool f = 0; int x = 0; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') { if (ch == '-') f = true; ch = getchar(); } while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0', ch = getchar(); return (!f) ? x : -x;}double calc(double nx, double ny){ double sum = 0; for (int i = 1; i &lt;= n; i++) { double x = nx - a[i].x; double y = ny - a[i].y; sum += sqrt(x * x + y * y) * a[i].w; } return sum;}void sa(){ double nowx = ansx, nowy = ansy; t = 1000000; while (t &gt; 1e-14) { double tmpx = ansx + (rand() * 2 - RAND_MAX) * t; double tmpy = ansy + (rand() * 2 - RAND_MAX) * t; double tmp = calc(tmpx, tmpy); if (tmp - ans &lt; 0) { nowx = tmpx; nowy = tmpy; ansx = tmpx; ansy = tmpy; ans = tmp; } else if (exp((ans - tmp) / t) * RAND_MAX &gt; rand()) { nowx = tmpx; nowy = tmpy; } t *= delta; }}int main(){ n = read(); srand(19260817); for (int i = 1; i &lt;= n; i++) a[i].x = read(), a[i].y = read(), a[i].w = read(); sa(); printf(\"%.3lf %.3lf\", ansx, ansy); return 0;}","link":"/2019/02/06/洛谷1337/"},{"title":"洛谷 P2485 【[SDOI2011]计算器】","text":"数论三合一大礼包第一问快速幂不讲了 第二问要你求的是$x*y \\equiv z \\mod p$ 即 $xy - kp = z$ 即 $xy + p*(-k) = z$ 就转换为$exgcd$的标准形式了（这个相信大家都会吧） 第三问BSGS模板题 有兴趣可以看P4195 exBSGS模板 注意$b$有可能大于$p$，所以要膜一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;bits/stdc++.h&gt;#define ll long long#define int llstd::unordered_map&lt;int, int&gt; h;int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }inline int mul(int a, int b, int p){ ll ret = 0; while(b) { if (b &amp; 1) ret = (ret + a) % p; a = (a + a) % p; b &gt;&gt;= 1; } return ret;}void exgcd(int a, int b, int &amp;x, int &amp;y){ if (b == 0) { x = 1, y = 0; return; } exgcd(b, a % b, x, y); int t = x; x = y, y = t - (a / b) * y;}int solve1(int a, int b, int p){ ll ret = 1; while (b) { if (b &amp; 1) ret = mul(ret, a, p); a = mul(a, a, p); b &gt;&gt;= 1; } return ret;}int solve2(int a, int b, int p){ int x = 0, y = 0; int g = gcd(a, p); if (b % g) return -1; exgcd(a, p, x, y); x *= (b / g); x = (x % p + p) % p; return x;}int solve3(int a, int b, int p){ if (b == 1) return 0; int cnt = 0, d, k = 1; while ((d = gcd(a, p)) ^ 1) { if (b % d) return -1; b /= d, p /= d, ++cnt; k = mul(k, a / d, p); if (k == b) return cnt; } int t = sqrt(p) + 1, tmp = 1; h.clear(); for (int i = 0; i &lt; t; i++) { h[mul(tmp, b, p)] = i; tmp = mul(tmp, a, p); } k = mul(k, tmp, p); for (int i = 1; i &lt;= t; i++) { if (h.find(k) != h.end()) return i * t - h[k] + cnt; k = mul(k, tmp, p); } return -1;}signed main(){ int T, op; scanf(\"%lld%lld\", &amp;T, &amp;op); while (T--) { int a, b, p; scanf(\"%lld%lld%lld\", &amp;a, &amp;b, &amp;p); if (op == 1) printf(\"%lld\\n\", solve1(a, b, p)); if (op == 2) { b %= p; int ans = solve2(a, b, p); if (ans == -1) printf(\"Orz, I cannot find x!\\n\"); else printf(\"%lld\\n\", ans); } if (op == 3) { b %= p;//注意这个！ int ans = solve3(a, b, p); if (ans == -1) printf(\"Orz, I cannot find x!\\n\"); else printf(\"%lld\\n\", ans); } } return 0;}","link":"/2019/02/06/洛谷2485/"},{"title":"洛谷1156 垃圾陷阱","text":"一道简单的动态规划 将每个垃圾按扔下来的时间从小到大排序 每次扔下来一个垃圾时，如果能靠这个垃圾爬出来就123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051不然就继续最后如果挂了的话算一下他能撑多久```cpp#include &lt;bits/stdc++.h&gt;const int MaxN = 100010;struct node{ int t, f, h;};node a[MaxN];int d, g, f[MaxN];inline int cmp(node a, node b){ return a.t &lt; b.t;}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; &apos;9&apos; || ch &lt; &apos;0&apos;) ch = getchar(); while (ch &lt;= &apos;9&apos; &amp;&amp; ch &gt;= &apos;0&apos;) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}int main(){ d = read(), g = read(); for (int i = 1; i &lt;= g; i++) a[i].t = read(), a[i].f = read(), a[i].h = read(); std::sort(a + 1, a + g + 1, cmp); f[0] = 10; for (int i = 1; i &lt;= g; i++) { for (int j = d; j &gt;= 0; j--) { if (f[j] &gt;= a[i].t) { if (j + a[i].h &gt;= d) return 0 * printf(&quot;%d\\n&quot;, a[i].t); f[j + a[i].h] = std::max(f[j], f[j + a[i].h]); f[j] += a[i].f; } } } printf(&quot;%d\\n&quot;, f[0]); return 0;}","link":"/2019/02/24/洛谷1156/"},{"title":"洛谷 P2503 [HAOI2006]均分数据","text":"模拟退火写起来真舒服喵~ 首先我们把这$n$个数随机分成$m$组，然后退火时每次随机两个数交换分组，如果更优的话就保存，不然的话就以一定的概率接受该答案 记得多随机几次喵~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;const int MaxN = 50;const double delta = 0.995;int n, m;int a[MaxN], f[MaxN];double sum[MaxN], aver = 0, ans = 1e18;inline int read(){ int x = 0, f = 1; char ch = getchar(); while(ch &gt; '9' || ch &lt; '0') { if(ch == '-') f = 0; ch = getchar(); } while(ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return f ? x : (-x);}inline double calc(){ double tmp = 0; for (int i = 1; i &lt;= m; i++) tmp += (sum[i] - aver) * (sum[i] - aver); return tmp;}void sa(){ memset(sum, 0, sizeof(sum)); double tmp = 0; for(int i = 1; i &lt;= n; i++) f[i] = rand() % m + 1, sum[f[i]] += a[i]; for(int i = 1; i &lt;= m; i++) tmp += (sum[i] - aver) * (sum[i] - aver); double t = 10000000; while(t &gt; 1e-14) { int x = rand() % n + 1, y = rand() % n + 1; while(f[x] == f[y]) x = rand() % n + 1, y = rand() % n + 1; sum[f[x]] -= a[x]; sum[f[x]] += a[y]; sum[f[y]] += a[x]; sum[f[y]] -= a[y]; double now = calc(); if ((now &lt; tmp) || (exp((now - tmp) / t) * RAND_MAX &lt; rand())) tmp = now, std::swap(f[x], f[y]); else sum[f[x]] += (a[x] - a[y]), sum[f[y]] += (a[y] - a[x]); t *= delta; } if(tmp &lt; ans) ans = tmp;}int main(){ srand(time(NULL)); n = read(), m = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(), aver += a[i]; aver /= m; for(int i = 1; i &lt;= 500; i++) sa(); printf(\"%.2lf\", sqrt(ans / m)); return 0;}","link":"/2019/02/07/洛谷2503/"},{"title":"洛谷 P3878 [TJOI2010]分金币","text":"题目大意将$n$个数分成两半，使得这两半的差尽量小 Solution我们首先先把这$n$个数按下标顺序分成两组，然后每次随机选取前半段和后半段的两个数将其交换，如果更优的话就更新$ans$,否则就以$e^{\\frac{-de}{t}}$（$de=$当前解-最优解）的概率接受该交换(其实就是模拟退火的基本套路) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define ll long longconst int MaxN = 50;const double delta = 0.993;ll n, a[MaxN], ans;ll abs(ll x){ return (x &gt; 0) ? x : (-x);}inline ll calc(){ ll sum1 = 0, sum2 = 0; for (int i = 1; i &lt;= n; i++) { if(i &lt;= (n + 1) / 2) sum1 += a[i]; else sum2 += a[i]; } return abs(sum1 - sum2);}inline void sa(){ double t = 10000000; while (t &gt; 1e-14) { int x = rand() % ((n + 1) / 2) + 1, y = rand() % ((n + 1) / 2) + ((n + 1) / 2); std::swap(a[x], a[y]); int now = calc(); int de = now - ans; if (de &lt; 0) ans = now; else if (exp(-de / t) * RAND_MAX &lt;= rand()) std::swap(a[x], a[y]); t *= delta; }}int main(){ int T; srand(time(NULL)); scanf(\"%d\", &amp;T); while (T--) { scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%lld\", &amp;a[i]); ans = 1e9; for (int i = 1; i &lt;= 50; i++) sa(); printf(\"%lld\\n\", ans); } return 0;}","link":"/2019/02/10/洛谷3878/"},{"title":"「洛谷 P3674」 小清新人渣的本愿","text":"莫队+$bitset$优化 操作$1$： 维护一个$bitset:$ $cnt1$.$cnt1_i$表示$i$这个数是否出现 若存在数$y,z$使得$y-z=x$,则$y = z + x$ 故将$cnt1$与($cnt1&lt;&lt;x$)做与运算即可 操作$2​$： 维护两个$bitset: cnt1,cnt2$. $cnt1_i$表示$i$这个数是否出现,$cnt2_i$表示$MaxN-i$这个数是否出现 若存在数$y,z$使得$y+z=x$,则有$y + z - MaxN= x - MaxN$ 令$z’=MaxN-z$，则原式转化为$y - z’ = x - MaxN$ 那么就变成了操作1了。。。只不过这次在cnt2中查$z’$ 故将$cnt1$与$(cnt2&gt;&gt;($MaxN-x$))$做与运算即可(为什么右移$MaxN-x$位呢？因为cnt2和cnt1是反着存储的) 操作$3$： 暴力枚举$x$的约数查询即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;const int MaxN = 100010;struct query{ int id, pos; int op, l, r, x;};query q[MaxN];int n, m, size;int a[MaxN], cnt[MaxN], ans[MaxN];std::bitset&lt;100010&gt; cnt1, cnt2;inline int cmp(query a, query b){ if (a.pos != b.pos) return a.pos &lt; b.pos; else return a.r &lt; b.r;}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline void add(int x){ ++cnt[a[x]]; if(cnt[a[x]] == 1) cnt1[a[x]] = 1, cnt2[100000 - a[x]] = 1;}inline void del(int x){ --cnt[a[x]]; if(cnt[a[x]] == 0) cnt1[a[x]] = 0, cnt2[100000 - a[x]] = 0;}inline void solve(){ int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) { while (l &gt; q[i].l) --l, add(l); while (r &lt; q[i].r) ++r, add(r); while (l &lt; q[i].l) del(l), ++l; while (r &gt; q[i].r) del(r), --r; if (q[i].op == 1) ans[q[i].id] = (cnt1 &amp; (cnt1 &lt;&lt; q[i].x)).any(); else if (q[i].op == 2) ans[q[i].id] = (cnt1 &amp; (cnt2 &gt;&gt; (100000 - q[i].x))).any(); else if (q[i].op == 3) { for (int j = 1; j * j &lt;= q[i].x; j++) { if (q[i].x % j == 0) if (cnt1[j] &amp;&amp; cnt1[q[i].x / j]) ans[q[i].id] = 1; } } }}int main(){ n = read(), m = read(); size = pow(n, 0.55); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt;= n; i++) { q[i].op = read(), q[i].l = read(), q[i].r = read(), q[i].x = read(); q[i].id = i, q[i].pos = (q[i].l - 1) / size + 1; } std::sort(q + 1, q + m + 1, cmp); solve(); for (int i = 1; i &lt;= m; i++) puts(ans[i] == 1 ? \"hana\" : \"bi\"); return 0;}","link":"/2019/02/12/洛谷3674/"},{"title":"「模板」Miller_Rabin","text":"提交地址: LOJ #143. 质数判定 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define ll long longconst int cnt = 2500;const int mod[] = {3, 5, 7, 11, 13, 17, 19, 23, 29};ll fast_mul(ll a, ll b, ll m){ ll d = ((long double)a / m * b + 0.5); ll r = a * b - d * m; return r &lt; 0 ? r + m : r;}ll fast_pow(ll a, ll m, ll n){ ll ret = 1; while (m) { if (m &amp; 1) ret = fast_mul(ret, a, n); a = fast_mul(a, a, n); m &gt;&gt;= 1; } return ret;}bool check(ll k){ if (k &lt;= 1) return false; if (k == 2) return true; if (!(k &amp; 1)) return false; ll t = k - 1; int now = 0; while (!(t &amp; 1)) t &gt;&gt;= 1, ++now; for (int i = 0; i &lt; 9; i++) { if (mod[i] == k) return 1; ll x = fast_pow(mod[i], t, k), y = x; for (int j = 1; j &lt;= now; j++) { x = fast_mul(x, x, k); if (x == 1 &amp;&amp; !(y == 1 || y == k - 1)) return false; y = x; } if (x != 1) return 0; } return true;}int main(){ srand(time(NULL)); ll k; while (scanf(\"%llu\", &amp;k) == 1) printf(check(k) ? \"Y\\n\" : \"N\\n\"); return 0;}","link":"/2019/02/11/模板-MillerRabin/"},{"title":"UVA10228 A Star not a Tree?","text":"题目大意给定$n$个点, 求一个点使得这个点到所有$n$个点的距离最小，输出距离（保留整数） 题解计算几何什么的我不会o((⊙﹏⊙))o 那我们就来随机化吧(￣▽￣)~* 按照模拟退火的套路来：每次随机一个点，判他是不是比答案更优，如果更优的话就更新，否则就以一定的几率接受该解。直到稳定在最优解为止。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;const int MaxN = 200;const double delta = 0.995;int n;int x[MaxN], y[MaxN];double ansx, ansy;inline double calc(double nx, double ny){ double tmp = 0; for (int i = 1; i &lt;= n; i++) tmp += sqrt((nx - x[i]) * (nx - x[i]) + (ny - y[i]) * (ny - y[i])); return tmp;}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline void sa(){ double t = 10000000; while (t &gt; 1e-14) { double nowx = ansx + (rand() * 2 - RAND_MAX) * t; double nowy = ansy + (rand() * 2 - RAND_MAX) * t; double tmp = calc(nowx, nowy) - calc(ansx, ansy); if (tmp &lt; 0) ansx = nowx, ansy = nowy; else if (exp(-tmp / t) * RAND_MAX &gt; rand()) ansx = nowx, ansy = nowy; t *= delta; }}int main(){ srand(time(NULL)); int T = read(); while (T--) { ansx = ansy = 0; n = read(); for (int i = 1; i &lt;= n; i++) x[i] = read(), y[i] = read(); for (int i = 1; i &lt;= 100; i++) sa(); printf(\"%.0lf\\n\", calc(ansx, ansy)); if(T) printf(\"\\n\"); } return 0;}","link":"/2019/02/08/uva10228/"},{"title":"洛谷 P3936 Coloring","text":"思路其实很容易想到，只是调参有那么”一点点”恶心 首先按顺序把$1-c$这$c$种数全部填进表格里 然后每次随机选两个颜色不同的块交换，然后计算原方案与现方案的差距，并按几率更新 代码五分钟，调参两百年:C 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(3)using namespace std;const int MaxN = 30;const int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};int n, m, c;int p[51];int a[MaxN][MaxN], tmp[MaxN][MaxN];inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline int calc(int A[30][30]){ int ret = 0; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { for (int k = 0; k &lt;= 3; k++) { int nx = i + dx[k], ny = j + dy[k]; if (A[nx][ny] &amp;&amp; (A[nx][ny] != A[i][j])) ++ret; } } } return ret / 2;}inline void init(){ int now = 1, cnt = 0; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { a[i][j] = now; ++cnt; if (cnt == p[now]) cnt = 0, now++; } }}inline void sa(){ double t = 1.0, delta; if (n * m &lt;= 400) delta = 0.9999900001; memcpy(tmp, a, sizeof(a)); while (t &gt; 1e-5) { std::pair&lt;int, int&gt; pos1, pos2; pos1.first = rand() % n + 1; pos2.first = rand() % n + 1; pos1.second = rand() % m + 1; pos2.second = rand() % m + 1; while (tmp[pos1.first][pos1.second] == tmp[pos2.first][pos2.second]) { pos1.first = rand() % n + 1; pos2.first = rand() % n + 1; pos1.second = rand() % m + 1; pos2.second = rand() % m + 1; } std::swap(tmp[pos1.first][pos1.second], tmp[pos2.first][pos2.second]); int num = calc(tmp) - calc(a); if (num &lt; 0) std::swap(a[pos1.first][pos1.second], a[pos2.first][pos2.second]); else if (exp(-num / t) * RAND_MAX &gt; rand()) std::swap(a[pos1.first][pos1.second], a[pos2.first][pos2.second]); else std::swap(tmp[pos1.first][pos1.second], tmp[pos2.first][pos2.second]); t *= delta; }}int main(){ srand(107); n = read(), m = read(), c = read(); for (int i = 1; i &lt;= c; i++) p[i] = read(); init(); for (int i = 1; i &lt;= 2; i++) sa(); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) printf(\"%d \", a[i][j]); puts(\"\"); } return 0;}","link":"/2019/02/09/洛谷3936/"},{"title":"洛谷 P4396 [AHOI2013]作业","text":"思路：莫队+分块 这题其实跟Gty的二逼妹子序列非常像 把那题代码改改就行了 首先区间问题，可以离线，马上想到莫队 然后发现不会修改？怎么办？ (好像可以树状数组做，可是我不会o((⊙﹏⊙))o 我们可以把值域分块，这样就可以做到每次查询$O(\\sqrt n)​$，修改$O(1)​$了 总复杂度$O(m \\sqrt n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;#define getpos(x) ((x - 1) / block + 1)#define getblock(x) ((x - 1) * block + 1)const int MaxN = 100010;struct query{ int id, pos; int l, r, a, b;};query q[MaxN];int n, m, size, block;int a[MaxN], cnt[MaxN], sum[MaxN][3], ans[MaxN][3];inline int cmp(query a, query b){ if (a.pos != b.pos) return a.pos &lt; b.pos; return a.r &lt; b.r;}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline void add(int x){ ++cnt[a[x]]; ++sum[getpos(a[x])][1]; if (cnt[a[x]] == 1) ++sum[getpos(a[x])][2];}inline void del(int x){ --cnt[a[x]]; --sum[getpos(a[x])][1]; if (cnt[a[x]] == 0) --sum[getpos(a[x])][2];}inline void ask(int x){ int id = q[x].id, l = q[x].a, r = q[x].b, Posl = getpos(q[x].a), Posr = getpos(q[x].b); for (int i = Posl + 1; i &lt; Posr; i++) ans[id][1] += sum[i][1], ans[id][2] += sum[i][2]; if (Posl == Posr) { for (int i = l; i &lt;= r; i++) { ans[id][1] += cnt[i]; if (cnt[i]) ans[id][2]++; } } else { int L = getblock(Posr), R = getblock(Posl + 1) - 1; for (int i = l; i &lt;= R; i++) { ans[id][1] += cnt[i]; if (cnt[i]) ans[id][2]++; } for (int i = L; i &lt;= r; i++) { ans[id][1] += cnt[i]; if (cnt[i]) ans[id][2]++; } }}inline void solve(){ int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) { while (l &gt; q[i].l) --l, add(l); while (r &lt; q[i].r) ++r, add(r); while (l &lt; q[i].l) del(l), l++; while (r &gt; q[i].r) del(r), r--; ask(i); }}int main(){ n = read(), m = read(); size = pow(n, 0.55), block = sqrt(n); for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= m; i++) { q[i].l = read(), q[i].r = read(); q[i].a = read(), q[i].b = read(); q[i].id = i, q[i].pos = (q[i].l - 1) / size + 1; } std::sort(q + 1, q + m + 1, cmp); solve(); for (int i = 1; i &lt;= m; i++) printf(\"%d %d\\n\", ans[i][1], ans[i][2]); return 0;}","link":"/2019/02/06/洛谷4396/"},{"title":"「洛谷2146」软件包管理器","text":"zcy会写树剖啦！ 本题为树链剖分的模板题 对于”install x”操作, 将$x$到根节点路径上所有点的点权全部赋值为$1$ 对于”uninstall x”操作, 将$x$及$x$的子树点权全部赋值为$0$​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184// luogu-judger-enable-o2#include &lt;bits/stdc++.h&gt;using namespace std;const int MaxN = 150010;struct edge{ int to, next;};struct node{ int l, r; int sum, tag;};struct SegmentTree{ node t[MaxN &lt;&lt; 1]; inline void pushup(int id) { t[id].sum = t[id &lt;&lt; 1].sum + t[id &lt;&lt; 1 | 1].sum; } void build(int id, int l, int r) { t[id].l = l, t[id].r = r, t[id].tag = -1; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); } inline void pushdown(int id) { if (t[id].tag != -1) { t[id &lt;&lt; 1].sum = t[id].tag * (t[id &lt;&lt; 1].r - t[id &lt;&lt; 1].l + 1); t[id &lt;&lt; 1 | 1].sum = t[id].tag * (t[id &lt;&lt; 1 | 1].r - t[id &lt;&lt; 1 | 1].l + 1); t[id &lt;&lt; 1].tag = t[id].tag; t[id &lt;&lt; 1 | 1].tag = t[id].tag; t[id].tag = -1; } } inline void modify(int id, int l, int r, int delta) { if (l &gt; t[id].r || t[id].l &gt; r) return; if (l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) { t[id].sum = delta * (t[id].r - t[id].l + 1); t[id].tag = delta; return; } if (t[id].l == t[id].r) return; pushdown(id); modify(id &lt;&lt; 1, l, r, delta); modify(id &lt;&lt; 1 | 1, l, r, delta); pushup(id); return; } inline int query(int id, int l, int r) { if (l &gt; t[id].r || t[id].l &gt; r) return 0; if (l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) return t[id].sum; if (t[id].l == t[id].r) return 0; pushdown(id); return query(id &lt;&lt; 1, l, r) + query(id &lt;&lt; 1 | 1, l, r); }} T;edge e[MaxN &lt;&lt; 1];int n, m, cnt, dfsnum, size[MaxN], hson[MaxN];int head[MaxN], top[MaxN], dfn[MaxN], fa[MaxN], dep[MaxN];inline void add_edge(int u, int v){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;}inline void dfs1(int u, int f){ size[u] = 1; for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (v == f) continue; dep[v] = dep[u] + 1; fa[v] = u; dfs1(v, u); size[u] += size[v]; if (size[v] &gt; size[hson[u]]) hson[u] = v; }}inline void dfs2(int u, int Top){ ++dfsnum; dfn[u] = dfsnum; top[u] = Top; if (hson[u]) dfs2(hson[u], Top); for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (v == hson[u] || v == fa[u]) continue; dfs2(v, v); }}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline void update_tree(int u){ T.modify(1, dfn[u], dfn[u] + size[u] - 1, 0);}inline void update_chain(int u, int v, int delta){ while (top[u] != top[v]) { if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); T.modify(1, dfn[top[u]], dfn[u], delta); u = fa[top[u]]; } if (dep[u] &lt; dep[v]) swap(u, v); T.modify(1, dfn[v], dfn[u], delta);}signed main(){ n = read(); for (int i = 2; i &lt;= n; ++i) { int u = read() + 1; add_edge(i, u); add_edge(u, i); } dep[1] = 1, fa[1] = 0; dfs1(1, 0), dfs2(1, 1); T.build(1, 1, n); m = read(); for (int i = 1; i &lt;= m; i++) { string op; cin &gt;&gt; op; int before = T.t[1].sum; if (op == \"install\") { int u = read() + 1; update_chain(u, 1, 1); int after = T.t[1].sum; printf(\"%d\\n\", after - before); } else { int u = read() + 1; update_tree(u); int after = T.t[1].sum; printf(\"%d\\n\", before - after); } } return 0;}","link":"/2019/02/21/洛谷2146/"},{"title":"洛谷3178 [HAOI2015] 树上操作","text":"就是个树剖的模板题嘛。。。。 两边dfs把树割成链, 然后在链上线段树维护 做完了。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include &lt;bits/stdc++.h&gt;#define int long longconst int MaxN = 100010;struct edge{ int next, to;};struct node{ int l, r; int sum, tag;};edge e[MaxN &lt;&lt; 1];int n, m, cnt, dfscnt;int a[MaxN], head[MaxN], dfn[MaxN], pre[MaxN];int top[MaxN], dep[MaxN], hson[MaxN], fa[MaxN], size[MaxN];struct SegmentTree{ node t[MaxN &lt;&lt; 2]; inline void pushup(int id) { t[id].sum = t[id &lt;&lt; 1].sum + t[id &lt;&lt; 1 | 1].sum; } void build(int id, int l, int r) { t[id].l = l, t[id].r = r; if (l == r) { t[id].sum = a[pre[l]]; return; } int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); pushup(id); } inline void pushdown(int id) { if (t[id].tag) { t[id &lt;&lt; 1].sum += t[id].tag * (t[id &lt;&lt; 1].r - t[id &lt;&lt; 1].l + 1); t[id &lt;&lt; 1 | 1].sum += t[id].tag * (t[id &lt;&lt; 1 | 1].r - t[id &lt;&lt; 1 | 1].l + 1); t[id &lt;&lt; 1].tag += t[id].tag, t[id &lt;&lt; 1 | 1].tag += t[id].tag; t[id].tag = 0; } } void modify(int id, int l, int r, int delta) { if (l &gt; t[id].r || r &lt; t[id].l) return; if (l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) { t[id].sum += delta * (t[id].r - t[id].l + 1); t[id].tag += delta; return; } if (t[id].l == t[id].r) return; pushdown(id); modify(id &lt;&lt; 1, l, r, delta); modify(id &lt;&lt; 1 | 1, l, r, delta); pushup(id); } int query(int id, int l, int r) { if (l &gt; t[id].r || r &lt; t[id].l) return 0; if (l &lt;= t[id].l &amp;&amp; t[id].r &lt;= r) return t[id].sum; if (t[id].l == t[id].r) return 0; pushdown(id); return query(id &lt;&lt; 1, l, r) + query(id &lt;&lt; 1 | 1, l, r); }} T;inline void add_edge(int u, int v){ ++cnt; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt;}void dfs1(int u, int f){ size[u] = 1; for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (v == f) continue; dep[v] = dep[u] + 1, fa[v] = u; dfs1(v, u); size[u] += size[v]; if (size[v] &gt; size[hson[u]]) hson[u] = v; }}void dfs2(int u, int Top){ ++dfscnt; dfn[u] = dfscnt; pre[dfscnt] = u; top[u] = Top; if (hson[u]) dfs2(hson[u], Top); for (int i = head[u]; i; i = e[i].next) { int v = e[i].to; if (v == fa[u] || v == hson[u]) continue; dfs2(v, v); }}inline int read(){ int x = 0, f = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') { if (ch == '-') f = 0; ch = getchar(); } while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return f ? x : (-x);}inline int query(int u, int v){ int ans = 0; while (top[u] != top[v]) { if (dep[u] &lt; dep[v]) std::swap(u, v); ans += T.query(1, dfn[top[u]], dfn[u]); u = fa[top[u]]; } if (dep[u] &lt; dep[v]) std::swap(u, v); ans += T.query(1, dfn[v], dfn[u]); return ans;}signed main(){ n = read(), m = read(); for (int i = 1; i &lt;= n; i++) a[i] = read(); for (int i = 1; i &lt; n; i++) { int u = read(), v = read(); add_edge(u, v); add_edge(v, u); } dep[1] = 1, fa[1] = 0; dfs1(1, 0), dfs2(1, 1); T.build(1, 1, n); for (int i = 1; i &lt;= m; i++) { int op = read(); if (op == 1) { int u = read(), x = read(); T.modify(1, dfn[u], dfn[u], x); } if (op == 2) { int u = read(), x = read(); T.modify(1, dfn[u], dfn[u] + size[u] - 1, x); } if (op == 3) { int u = read(); printf(\"%lld\\n\", query(u, 1)); } } return 0;}","link":"/2019/02/22/洛谷3178/"},{"title":"洛谷 P5018 【对称二叉树】","text":"本题考察选手对DFS及树结构的掌握程度 首先，你把数据读入之后，先用一个大法师把以每个节点为根的子树的大小和权值都预处理出来，方便待会剪枝 然后，你对以每个节点为根的子树，都判断一下以下条件（这时刚才处理的东西就有用了） ① 左子树和右子树的节点数是否相等 ② 左子树和右子树的权值是否相等 ③ 以当前节点为根的子树大小是不是超过答案 第三个很重要，不加（洛谷 数据）最后一个点会TLE 有一个显而易见的剪枝：因为答案至少是1，所以大小为1的子树就不用check了，不然浪费常数 然后就是暴力判了 递归下去，建立两个队列，保存当前处理到的左子树上和右子树上的节点，判左子树当前节点的左儿子和右子树当前节点的右儿子权值是否相等，右子树当前节点的左儿子和左子树当前节点的右儿子权值是否相等（注意对应） 还有判下对应的节点有没有一个是空的一个没空的情况 如果不相等就返回 相等的话就扔进队列（注意对应顺序！） 注意：上述处理一定要左右子树一起做，不能先处理一边，再处理另一边，不然会WA 到最后如果都可以的话就return true 附考场代码 不得不说，为了能过，我加了一堆卡常 3e6的输入规模应该还是要快读的吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117# include &lt;bits/stdc++.h&gt;# define R register const int MaxN = 1000010;struct node//节点{ int val; int l, r;};node a[MaxN];int f[MaxN], val[MaxN], ind[MaxN];//f[i]表示以i为根的子树大小，val表示以i为根的子树权值和，ind没啥用inline void read(int &amp;x)//快读{ x = 0; bool op = 1; char ch = getchar(); while(ch &gt; '9' || ch &lt; '0') { if(ch == '-') op = 0; ch = getchar(); } while(ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch - '0'), ch = getchar(); if(!op) x = -x;}void dfs(int root){ if(root == -1) return; if(a[root].l == -1 &amp;&amp; a[root].r == -1) f[root] = 1, val[root] = a[root].val; else { dfs(a[root].l); dfs(a[root].r); f[root] = f[a[root].l] + f[a[root].r] + 1; val[root] = val[a[root].l] + val[a[root].r] + a[root].val; }}inline int check(int x){ std::queue&lt;int&gt; l, r; l.push(x), r.push(x); while(!l.empty() || !r.empty()) { if(l.empty() || r.empty()) return false;//一边空了，一边没空 R int lx = l.front(), rx = r.front(); l.pop(), r.pop(); if(a[lx].val != a[rx].val) return false; R int lson[3], rson[3]; lson[1] = a[lx].l, lson[2] = a[lx].r;//左子树当前节点的左儿子,左子树当前节点的右儿子 rson[1] = a[rx].l, rson[2] = a[rx].r;//右子树当前节点的左儿子,右子树当前节点的右儿子 if((lson[1] == -1 &amp;&amp; rson[2] != -1) || (lson[1] != -1 &amp;&amp; rson[2] == -1)) return false;//一边空了，一边没空 if((lson[2] == -1 &amp;&amp; rson[1] != -1) || (lson[2] != -1 &amp;&amp; rson[1] == -1)) return false;//一边空了，一边没空 if(lson[1] != -1) l.push(lson[1]); if(lson[2] != -1) l.push(lson[2]); if(rson[2] != -1) r.push(rson[2]); if(rson[1] != -1) r.push(rson[1]); //推进队列 } return true;}int main(){// freopen(\"tree.in\", \"r\", stdin);// freopen(\"tree.out\", \"w\", stdout); R int n; scanf(\"%d\", &amp;n); for(R unsigned i = 1; i &lt;= n; ++i) read(a[i].val); for(R unsigned i = 1; i &lt;= n; ++i) read(a[i].l), read(a[i].r), ++ind[a[i].l], ++ind[a[i].r];//处理入度 R unsigned root; for(R unsigned i = 1; i &lt;= n; ++i) { if(!ind[i]) { root = i; break; } }//找树根 dfs(root);//预处理 int ans = 1; for(R unsigned i = 1; i &lt;= n; ++i)//枚举子树 { if(f[a[i].l] != f[a[i].r]) continue;//剪枝1 if(val[a[i].l] != val[a[i].r]) continue;//剪枝2 if(f[i] &lt; ans || f[i] == 1) continue;//剪枝3 if(check(i)) ans = f[i];//更新答案 } printf(\"%d\", ans); fclose(stdin); fclose(stdout); return 0;}","link":"/2019/02/06/洛谷5018/"},{"title":"洛谷 P4867 【Gty的二逼妹子序列】","text":"莫队好题 这种题一看直接莫队啊 但是我们要想想怎么修改 一开始我想树状数组，但是我不会写o((⊙﹏⊙))o 后来看了一下Solution，发现可以将值域分块，这样就可以做到查询$O(\\sqrt n)$，修改$O(1)$了 总复杂度$O(m \\sqrt n)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;#define getindex(x) ((x - 1) * block + 1)#define getpos(x) ((x - 1) / block + 1)const int MaxN = 1e5 + 10, MaxM = 1e6 + 10;struct query{ int id, pos; int l, r, a, b;};query q[MaxM];int n, m, size, block;int a[MaxN], ans[MaxM], cnt[MaxN], sum[MaxN];inline int cmp(query a, query b){ if (a.pos != b.pos) return a.pos &lt; b.pos; return a.r &lt; b.r;}inline int read(){ int x = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); while (ch &lt;= '9' &amp;&amp; ch &gt;= '0') x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return x;}inline void ins(int x){ ++cnt[a[x]]; if (cnt[a[x]] == 1) ++sum[getpos(a[x])];}inline void del(int x){ --cnt[a[x]]; if (cnt[a[x]] == 0) --sum[getpos(a[x])];}inline int ask(int a, int b, int l, int r){ int ans = 0, Posl = getpos(l), Posr = getpos(r); for (int i = Posl + 1; i &lt; Posr; i++) ans += sum[i]; if (Posl == Posr) { for (int i = l; i &lt;= r; i++) if (cnt[i]) ++ans; } else { int L = getindex(Posr), R = getindex(Posl + 1) - 1; for (int i = l; i &lt;= R; i++) if (cnt[i]) ++ans; for (int i = L; i &lt;= r; i++) if (cnt[i]) ++ans; } return ans;}inline void solve(){ int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) { while (l &gt; q[i].l) l--, ins(l); while (r &lt; q[i].r) r++, ins(r); while (l &lt; q[i].l) del(l), l++; while (r &gt; q[i].r) del(r), r--; ans[q[i].id] = ask(q[i].l, q[i].r, q[i].a, q[i].b); }}int main(){ n = read(), m = read(); size = pow(n, 0.55), block = sqrt(n); for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= m; ++i) { q[i].l = read(), q[i].r = read(); q[i].a = read(), q[i].b = read(); q[i].id = i, q[i].pos = (q[i].l - 1) / size + 1; } std::sort(q + 1, q + m + 1, cmp); solve(); for (int i = 1; i &lt;= m; i++) printf(\"%d\\n\", ans[i]); return 0;}","link":"/2019/02/06/洛谷4867/"},{"title":"洛谷 P3950 部落冲突","text":"link-cut tree 板子题 这道题可以用来作为link-cut tree的练手题 C操作:把发生战争的俩部落的连边cut掉 U操作:把停战的俩部落link起来 Q操作:如果p部落和q部落在一棵树里(树根相同)，就输出”Yes”,否则输出”No” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;bits/stdc++.h&gt;using namespace std;const int MaxN = 300010;int n, m, val[MaxN], p[MaxN], q[MaxN], war;struct Link_Cut_Tree{ int top, ch[MaxN][2], fa[MaxN], sum[MaxN], q[MaxN], rev[MaxN]; inline void pushup(int x) { sum[x] = sum[ch[x][0]] ^ sum[ch[x][1]] ^ val[x]; } inline void pushdown(int x) { int l = ch[x][0], r = ch[x][1]; if (rev[x]) { rev[l] ^= 1; rev[r] ^= 1; rev[x] ^= 1; swap(ch[x][0], ch[x][1]); } } inline bool isroot(int x) { return ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x; } void rotate(int x) { int y = fa[x], z = fa[y], l, r; if (ch[y][0] == x) l = 0; else l = 1; r = l ^ 1; if (!isroot(y)) { if (ch[z][0] == y) ch[z][0] = x; else ch[z][1] = x; } fa[x] = z; fa[y] = x; fa[ch[x][r]] = y; ch[y][l] = ch[x][r], ch[x][r] = y; pushup(y), pushup(x); } void splay(int x) { top = 1; q[top] = x; for (int i = x; !isroot(i); i = fa[i]) q[++top] = fa[i]; for (int i = top; i; i--) pushdown(q[i]); while (!isroot(x)) { int y = fa[x], z = fa[y]; if (!isroot(y)) { if ((ch[y][0] == x) ^ (ch[z][0] == y)) rotate(x); else rotate(y); } rotate(x); } } void access(int x) { for (int t = 0; x; t = x, x = fa[x]) splay(x), ch[x][1] = t, pushup(x); } void makeroot(int x) { access(x); splay(x); rev[x] ^= 1; } int find(int x) { access(x); splay(x); while (ch[x][0]) x = ch[x][0]; return x; } void split(int x, int y) { makeroot(x); access(y); splay(y); } void cut(int x, int y) { makeroot(x); if (find(y) != x || fa[x] != y || ch[x][1]) return; fa[x] = ch[y][0] = 0; pushup(y); } void link(int x, int y) { makeroot(x); fa[x] = y; }} t;int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 1; i &lt; n; i++) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); t.link(u, v); } for(int i = 1; i &lt;= m; i++) { std::string op; std::cin &gt;&gt; op; if(op == \"Q\") { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); int fx = t.find(x), fy = t.find(y); if(fx == fy) printf(\"Yes\\n\"); else printf(\"No\\n\"); } else if(op == \"C\") { ++war; scanf(\"%d%d\", &amp;p[war], &amp;q[war]); t.cut(p[war], q[war]); } else { int x; scanf(\"%d\", &amp;x); t.link(p[x], q[x]); } } return 0;}","link":"/2019/02/07/洛谷3950/"}],"tags":[{"name":"莫队","slug":"莫队","link":"/tags/莫队/"},{"name":"Data Structure","slug":"Data-Structure","link":"/tags/Data-Structure/"},{"name":"dijkstra","slug":"dijkstra","link":"/tags/dijkstra/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"},{"name":"search","slug":"search","link":"/tags/search/"},{"name":"bfs","slug":"bfs","link":"/tags/bfs/"},{"name":"其他","slug":"其他","link":"/tags/其他/"},{"name":"DFS序","slug":"DFS序","link":"/tags/DFS序/"},{"name":"二分","slug":"二分","link":"/tags/二分/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"tree","slug":"tree","link":"/tags/tree/"},{"name":"模拟退火","slug":"模拟退火","link":"/tags/模拟退火/"},{"name":"随机化","slug":"随机化","link":"/tags/随机化/"},{"name":"动态规划","slug":"动态规划","link":"/tags/动态规划/"},{"name":"MillerRabin","slug":"MillerRabin","link":"/tags/MillerRabin/"},{"name":"分块","slug":"分块","link":"/tags/分块/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/树链剖分/"},{"name":"NOI","slug":"NOI","link":"/tags/NOI/"},{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"link-cut tree","slug":"link-cut-tree","link":"/tags/link-cut-tree/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Solution","slug":"Solution","link":"/categories/Solution/"},{"name":"Contest","slug":"Contest","link":"/categories/Contest/"},{"name":"Template","slug":"Template","link":"/categories/Template/"}]}